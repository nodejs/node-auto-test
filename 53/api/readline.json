{
  "type": "module",
  "source": "doc/api/readline.md",
  "modules": [
    {
      "textRaw": "Readline",
      "name": "readline",
      "introduced_in": "v0.10.0",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p><strong>Source Code:</strong> <a href=\"https://github.com/nodejs/node/blob/v20.0.0/lib/readline.js\">lib/readline.js</a></p>\n<p>The <code>node:readline</code> module provides an interface for reading data from a\n<a href=\"stream.html#readable-streams\">Readable</a> stream (such as <a href=\"process.html#processstdin\"><code>process.stdin</code></a>) one line at a time.</p>\n<p>To use the promise-based APIs:</p>\n<pre><code class=\"language-mjs\">import * as readline from 'node:readline/promises';\n</code></pre>\n<pre><code class=\"language-cjs\">const readline = require('node:readline/promises');\n</code></pre>\n<p>To use the callback and sync APIs:</p>\n<pre><code class=\"language-mjs\">import * as readline from 'node:readline';\n</code></pre>\n<pre><code class=\"language-cjs\">const readline = require('node:readline');\n</code></pre>\n<p>The following simple example illustrates the basic use of the <code>node:readline</code>\nmodule.</p>\n<pre><code class=\"language-mjs\">import * as readline from 'node:readline/promises';\nimport { stdin as input, stdout as output } from 'node:process';\n\nconst rl = readline.createInterface({ input, output });\n\nconst answer = await rl.question('What do you think of Node.js? ');\n\nconsole.log(`Thank you for your valuable feedback: ${answer}`);\n\nrl.close();\n</code></pre>\n<pre><code class=\"language-cjs\">const readline = require('node:readline');\nconst { stdin: input, stdout: output } = require('node:process');\n\nconst rl = readline.createInterface({ input, output });\n\nrl.question('What do you think of Node.js? ', (answer) => {\n  // TODO: Log the answer in a database\n  console.log(`Thank you for your valuable feedback: ${answer}`);\n\n  rl.close();\n});\n</code></pre>\n<p>Once this code is invoked, the Node.js application will not terminate until the\n<code>readline.Interface</code> is closed because the interface waits for data to be\nreceived on the <code>input</code> stream.</p>\n<p><a id='readline_class_interface'></a></p>",
      "classes": [
        {
          "textRaw": "Class: `InterfaceConstructor`",
          "type": "class",
          "name": "InterfaceConstructor",
          "meta": {
            "added": [
              "v0.1.104"
            ],
            "changes": []
          },
          "desc": "<ul>\n<li>Extends: <a href=\"events.html#class-eventemitter\" class=\"type\">&lt;EventEmitter&gt;</a></li>\n</ul>\n<p>Instances of the <code>InterfaceConstructor</code> class are constructed using the\n<code>readlinePromises.createInterface()</code> or <code>readline.createInterface()</code> method.\nEvery instance is associated with a single <code>input</code> <a href=\"stream.html#readable-streams\">Readable</a> stream and a\nsingle <code>output</code> <a href=\"stream.html#writable-streams\">Writable</a> stream.\nThe <code>output</code> stream is used to print prompts for user input that arrives on,\nand is read from, the <code>input</code> stream.</p>",
          "events": [
            {
              "textRaw": "Event: `'close'`",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'close'</code> event is emitted when one of the following occur:</p>\n<ul>\n<li>The <code>rl.close()</code> method is called and the <code>InterfaceConstructor</code> instance has\nrelinquished control over the <code>input</code> and <code>output</code> streams;</li>\n<li>The <code>input</code> stream receives its <code>'end'</code> event;</li>\n<li>The <code>input</code> stream receives <kbd>Ctrl</kbd>+<kbd>D</kbd> to signal\nend-of-transmission (EOT);</li>\n<li>The <code>input</code> stream receives <kbd>Ctrl</kbd>+<kbd>C</kbd> to signal <code>SIGINT</code>\nand there is no <code>'SIGINT'</code> event listener registered on the\n<code>InterfaceConstructor</code> instance.</li>\n</ul>\n<p>The listener function is called without passing any arguments.</p>\n<p>The <code>InterfaceConstructor</code> instance is finished once the <code>'close'</code> event is\nemitted.</p>"
            },
            {
              "textRaw": "Event: `'line'`",
              "type": "event",
              "name": "line",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'line'</code> event is emitted whenever the <code>input</code> stream receives an\nend-of-line input (<code>\\n</code>, <code>\\r</code>, or <code>\\r\\n</code>). This usually occurs when the user\npresses <kbd>Enter</kbd> or <kbd>Return</kbd>.</p>\n<p>The <code>'line'</code> event is also emitted if new data has been read from a stream and\nthat stream ends without a final end-of-line marker.</p>\n<p>The listener function is called with a string containing the single line of\nreceived input.</p>\n<pre><code class=\"language-js\">rl.on('line', (input) => {\n  console.log(`Received: ${input}`);\n});\n</code></pre>"
            },
            {
              "textRaw": "Event: `'history'`",
              "type": "event",
              "name": "history",
              "meta": {
                "added": [
                  "v15.8.0",
                  "v14.18.0"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'history'</code> event is emitted whenever the history array has changed.</p>\n<p>The listener function is called with an array containing the history array.\nIt will reflect all changes, added lines and removed lines due to\n<code>historySize</code> and <code>removeHistoryDuplicates</code>.</p>\n<p>The primary purpose is to allow a listener to persist the history.\nIt is also possible for the listener to change the history object. This\ncould be useful to prevent certain lines to be added to the history, like\na password.</p>\n<pre><code class=\"language-js\">rl.on('history', (history) => {\n  console.log(`Received: ${history}`);\n});\n</code></pre>"
            },
            {
              "textRaw": "Event: `'pause'`",
              "type": "event",
              "name": "pause",
              "meta": {
                "added": [
                  "v0.7.5"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'pause'</code> event is emitted when one of the following occur:</p>\n<ul>\n<li>The <code>input</code> stream is paused.</li>\n<li>The <code>input</code> stream is not paused and receives the <code>'SIGCONT'</code> event. (See\nevents <a href=\"#event-sigtstp\"><code>'SIGTSTP'</code></a> and <a href=\"#event-sigcont\"><code>'SIGCONT'</code></a>.)</li>\n</ul>\n<p>The listener function is called without passing any arguments.</p>\n<pre><code class=\"language-js\">rl.on('pause', () => {\n  console.log('Readline paused.');\n});\n</code></pre>"
            },
            {
              "textRaw": "Event: `'resume'`",
              "type": "event",
              "name": "resume",
              "meta": {
                "added": [
                  "v0.7.5"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'resume'</code> event is emitted whenever the <code>input</code> stream is resumed.</p>\n<p>The listener function is called without passing any arguments.</p>\n<pre><code class=\"language-js\">rl.on('resume', () => {\n  console.log('Readline resumed.');\n});\n</code></pre>"
            },
            {
              "textRaw": "Event: `'SIGCONT'`",
              "type": "event",
              "name": "SIGCONT",
              "meta": {
                "added": [
                  "v0.7.5"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'SIGCONT'</code> event is emitted when a Node.js process previously moved into\nthe background using <kbd>Ctrl</kbd>+<kbd>Z</kbd> (i.e. <code>SIGTSTP</code>) is then\nbrought back to the foreground using <a href=\"http://man7.org/linux/man-pages/man1/fg.1p.html\"><code>fg(1p)</code></a>.</p>\n<p>If the <code>input</code> stream was paused <em>before</em> the <code>SIGTSTP</code> request, this event will\nnot be emitted.</p>\n<p>The listener function is invoked without passing any arguments.</p>\n<pre><code class=\"language-js\">rl.on('SIGCONT', () => {\n  // `prompt` will automatically resume the stream\n  rl.prompt();\n});\n</code></pre>\n<p>The <code>'SIGCONT'</code> event is <em>not</em> supported on Windows.</p>"
            },
            {
              "textRaw": "Event: `'SIGINT'`",
              "type": "event",
              "name": "SIGINT",
              "meta": {
                "added": [
                  "v0.3.0"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'SIGINT'</code> event is emitted whenever the <code>input</code> stream receives\na <kbd>Ctrl+C</kbd> input, known typically as <code>SIGINT</code>. If there are no\n<code>'SIGINT'</code> event listeners registered when the <code>input</code> stream receives a\n<code>SIGINT</code>, the <code>'pause'</code> event will be emitted.</p>\n<p>The listener function is invoked without passing any arguments.</p>\n<pre><code class=\"language-js\">rl.on('SIGINT', () => {\n  rl.question('Are you sure you want to exit? ', (answer) => {\n    if (answer.match(/^y(es)?$/i)) rl.pause();\n  });\n});\n</code></pre>"
            },
            {
              "textRaw": "Event: `'SIGTSTP'`",
              "type": "event",
              "name": "SIGTSTP",
              "meta": {
                "added": [
                  "v0.7.5"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'SIGTSTP'</code> event is emitted when the <code>input</code> stream receives\na <kbd>Ctrl</kbd>+<kbd>Z</kbd> input, typically known as <code>SIGTSTP</code>. If there are\nno <code>'SIGTSTP'</code> event listeners registered when the <code>input</code> stream receives a\n<code>SIGTSTP</code>, the Node.js process will be sent to the background.</p>\n<p>When the program is resumed using <a href=\"http://man7.org/linux/man-pages/man1/fg.1p.html\"><code>fg(1p)</code></a>, the <code>'pause'</code> and <code>'SIGCONT'</code> events\nwill be emitted. These can be used to resume the <code>input</code> stream.</p>\n<p>The <code>'pause'</code> and <code>'SIGCONT'</code> events will not be emitted if the <code>input</code> was\npaused before the process was sent to the background.</p>\n<p>The listener function is invoked without passing any arguments.</p>\n<pre><code class=\"language-js\">rl.on('SIGTSTP', () => {\n  // This will override SIGTSTP and prevent the program from going to the\n  // background.\n  console.log('Caught SIGTSTP.');\n});\n</code></pre>\n<p>The <code>'SIGTSTP'</code> event is <em>not</em> supported on Windows.</p>"
            }
          ],
          "methods": [
            {
              "textRaw": "`rl.close()`",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>The <code>rl.close()</code> method closes the <code>InterfaceConstructor</code> instance and\nrelinquishes control over the <code>input</code> and <code>output</code> streams. When called,\nthe <code>'close'</code> event will be emitted.</p>\n<p>Calling <code>rl.close()</code> does not immediately stop other events (including <code>'line'</code>)\nfrom being emitted by the <code>InterfaceConstructor</code> instance.</p>"
            },
            {
              "textRaw": "`rl.pause()`",
              "type": "method",
              "name": "pause",
              "meta": {
                "added": [
                  "v0.3.4"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>The <code>rl.pause()</code> method pauses the <code>input</code> stream, allowing it to be resumed\nlater if necessary.</p>\n<p>Calling <code>rl.pause()</code> does not immediately pause other events (including\n<code>'line'</code>) from being emitted by the <code>InterfaceConstructor</code> instance.</p>"
            },
            {
              "textRaw": "`rl.prompt([preserveCursor])`",
              "type": "method",
              "name": "prompt",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`preserveCursor` {boolean} If `true`, prevents the cursor placement from being reset to `0`.",
                      "name": "preserveCursor",
                      "type": "boolean",
                      "desc": "If `true`, prevents the cursor placement from being reset to `0`."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>rl.prompt()</code> method writes the <code>InterfaceConstructor</code> instances configured\n<code>prompt</code> to a new line in <code>output</code> in order to provide a user with a new\nlocation at which to provide input.</p>\n<p>When called, <code>rl.prompt()</code> will resume the <code>input</code> stream if it has been\npaused.</p>\n<p>If the <code>InterfaceConstructor</code> was created with <code>output</code> set to <code>null</code> or\n<code>undefined</code> the prompt is not written.</p>"
            },
            {
              "textRaw": "`rl.resume()`",
              "type": "method",
              "name": "resume",
              "meta": {
                "added": [
                  "v0.3.4"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>The <code>rl.resume()</code> method resumes the <code>input</code> stream if it has been paused.</p>"
            },
            {
              "textRaw": "`rl.setPrompt(prompt)`",
              "type": "method",
              "name": "setPrompt",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`prompt` {string}",
                      "name": "prompt",
                      "type": "string"
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>rl.setPrompt()</code> method sets the prompt that will be written to <code>output</code>\nwhenever <code>rl.prompt()</code> is called.</p>"
            },
            {
              "textRaw": "`rl.getPrompt()`",
              "type": "method",
              "name": "getPrompt",
              "meta": {
                "added": [
                  "v15.3.0",
                  "v14.17.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string} the current prompt string",
                    "name": "return",
                    "type": "string",
                    "desc": "the current prompt string"
                  },
                  "params": []
                }
              ],
              "desc": "<p>The <code>rl.getPrompt()</code> method returns the current prompt used by <code>rl.prompt()</code>.</p>"
            },
            {
              "textRaw": "`rl.write(data[, key])`",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`data` {string}",
                      "name": "data",
                      "type": "string"
                    },
                    {
                      "textRaw": "`key` {Object}",
                      "name": "key",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`ctrl` {boolean} `true` to indicate the <kbd>Ctrl</kbd> key.",
                          "name": "ctrl",
                          "type": "boolean",
                          "desc": "`true` to indicate the <kbd>Ctrl</kbd> key."
                        },
                        {
                          "textRaw": "`meta` {boolean} `true` to indicate the <kbd>Meta</kbd> key.",
                          "name": "meta",
                          "type": "boolean",
                          "desc": "`true` to indicate the <kbd>Meta</kbd> key."
                        },
                        {
                          "textRaw": "`shift` {boolean} `true` to indicate the <kbd>Shift</kbd> key.",
                          "name": "shift",
                          "type": "boolean",
                          "desc": "`true` to indicate the <kbd>Shift</kbd> key."
                        },
                        {
                          "textRaw": "`name` {string} The name of the a key.",
                          "name": "name",
                          "type": "string",
                          "desc": "The name of the a key."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>rl.write()</code> method will write either <code>data</code> or a key sequence identified\nby <code>key</code> to the <code>output</code>. The <code>key</code> argument is supported only if <code>output</code> is\na <a href=\"tty.html\">TTY</a> text terminal. See <a href=\"#tty-keybindings\">TTY keybindings</a> for a list of key\ncombinations.</p>\n<p>If <code>key</code> is specified, <code>data</code> is ignored.</p>\n<p>When called, <code>rl.write()</code> will resume the <code>input</code> stream if it has been\npaused.</p>\n<p>If the <code>InterfaceConstructor</code> was created with <code>output</code> set to <code>null</code> or\n<code>undefined</code> the <code>data</code> and <code>key</code> are not written.</p>\n<pre><code class=\"language-js\">rl.write('Delete this!');\n// Simulate Ctrl+U to delete the line written previously\nrl.write(null, { ctrl: true, name: 'u' });\n</code></pre>\n<p>The <code>rl.write()</code> method will write the data to the <code>readline</code> <code>Interface</code>'s\n<code>input</code> <em>as if it were provided by the user</em>.</p>"
            },
            {
              "textRaw": "`rl[Symbol.asyncIterator]()`",
              "type": "method",
              "name": "[Symbol.asyncIterator]",
              "meta": {
                "added": [
                  "v11.4.0",
                  "v10.16.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v11.14.0",
                      "v10.17.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/26989",
                    "description": "Symbol.asyncIterator support is no longer experimental."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {AsyncIterator}",
                    "name": "return",
                    "type": "AsyncIterator"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Create an <code>AsyncIterator</code> object that iterates through each line in the input\nstream as a string. This method allows asynchronous iteration of\n<code>InterfaceConstructor</code> objects through <code>for await...of</code> loops.</p>\n<p>Errors in the input stream are not forwarded.</p>\n<p>If the loop is terminated with <code>break</code>, <code>throw</code>, or <code>return</code>,\n<a href=\"#rlclose\"><code>rl.close()</code></a> will be called. In other words, iterating over a\n<code>InterfaceConstructor</code> will always consume the input stream fully.</p>\n<p>Performance is not on par with the traditional <code>'line'</code> event API. Use <code>'line'</code>\ninstead for performance-sensitive applications.</p>\n<pre><code class=\"language-js\">async function processLineByLine() {\n  const rl = readline.createInterface({\n    // ...\n  });\n\n  for await (const line of rl) {\n    // Each line in the readline input will be successively available here as\n    // `line`.\n  }\n}\n</code></pre>\n<p><code>readline.createInterface()</code> will start to consume the input stream once\ninvoked. Having asynchronous operations between interface creation and\nasynchronous iteration may result in missed lines.</p>"
            },
            {
              "textRaw": "`rl.getCursorPos()`",
              "type": "method",
              "name": "getCursorPos",
              "meta": {
                "added": [
                  "v13.5.0",
                  "v12.16.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object",
                    "options": [
                      {
                        "textRaw": "`rows` {number} the row of the prompt the cursor currently lands on",
                        "name": "rows",
                        "type": "number",
                        "desc": "the row of the prompt the cursor currently lands on"
                      },
                      {
                        "textRaw": "`cols` {number} the screen column the cursor currently lands on",
                        "name": "cols",
                        "type": "number",
                        "desc": "the screen column the cursor currently lands on"
                      }
                    ]
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns the real position of the cursor in relation to the input\nprompt + string. Long input (wrapping) strings, as well as multiple\nline prompts are included in the calculations.</p>"
            }
          ],
          "properties": [
            {
              "textRaw": "`line` {string}",
              "type": "string",
              "name": "line",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": [
                  {
                    "version": [
                      "v15.8.0",
                      "v14.18.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/33676",
                    "description": "Value will always be a string, never undefined."
                  }
                ]
              },
              "desc": "<p>The current input data being processed by node.</p>\n<p>This can be used when collecting input from a TTY stream to retrieve the\ncurrent value that has been processed thus far, prior to the <code>line</code> event\nbeing emitted. Once the <code>line</code> event has been emitted, this property will\nbe an empty string.</p>\n<p>Be aware that modifying the value during the instance runtime may have\nunintended consequences if <code>rl.cursor</code> is not also controlled.</p>\n<p><strong>If not using a TTY stream for input, use the <a href=\"#event-line\"><code>'line'</code></a> event.</strong></p>\n<p>One possible use case would be as follows:</p>\n<pre><code class=\"language-js\">const values = ['lorem ipsum', 'dolor sit amet'];\nconst rl = readline.createInterface(process.stdin);\nconst showResults = debounce(() => {\n  console.log(\n    '\\n',\n    values.filter((val) => val.startsWith(rl.line)).join(' '),\n  );\n}, 300);\nprocess.stdin.on('keypress', (c, k) => {\n  showResults();\n});\n</code></pre>"
            },
            {
              "textRaw": "`cursor` {number|undefined}",
              "type": "number|undefined",
              "name": "cursor",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": []
              },
              "desc": "<p>The cursor position relative to <code>rl.line</code>.</p>\n<p>This will track where the current cursor lands in the input string, when\nreading input from a TTY stream. The position of cursor determines the\nportion of the input string that will be modified as input is processed,\nas well as the column where the terminal caret will be rendered.</p>"
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "Promises API",
          "name": "promises_api",
          "meta": {
            "added": [
              "v17.0.0"
            ],
            "changes": []
          },
          "stability": 1,
          "stabilityText": "Experimental",
          "classes": [
            {
              "textRaw": "Class: `readlinePromises.Interface`",
              "type": "class",
              "name": "readlinePromises.Interface",
              "meta": {
                "added": [
                  "v17.0.0"
                ],
                "changes": []
              },
              "desc": "<ul>\n<li>Extends: <a href=\"readline.html#class-interfaceconstructor\" class=\"type\">&lt;readline.InterfaceConstructor&gt;</a></li>\n</ul>\n<p>Instances of the <code>readlinePromises.Interface</code> class are constructed using the\n<code>readlinePromises.createInterface()</code> method. Every instance is associated with a\nsingle <code>input</code> <a href=\"stream.html#readable-streams\">Readable</a> stream and a single <code>output</code> <a href=\"stream.html#writable-streams\">Writable</a> stream.\nThe <code>output</code> stream is used to print prompts for user input that arrives on,\nand is read from, the <code>input</code> stream.</p>",
              "methods": [
                {
                  "textRaw": "`rl.question(query[, options])`",
                  "type": "method",
                  "name": "question",
                  "meta": {
                    "added": [
                      "v17.0.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {Promise} A promise that is fulfilled with the user's input in response to the `query`.",
                        "name": "return",
                        "type": "Promise",
                        "desc": "A promise that is fulfilled with the user's input in response to the `query`."
                      },
                      "params": [
                        {
                          "textRaw": "`query` {string} A statement or query to write to `output`, prepended to the prompt.",
                          "name": "query",
                          "type": "string",
                          "desc": "A statement or query to write to `output`, prepended to the prompt."
                        },
                        {
                          "textRaw": "`options` {Object}",
                          "name": "options",
                          "type": "Object",
                          "options": [
                            {
                              "textRaw": "`signal` {AbortSignal} Optionally allows the `question()` to be canceled using an `AbortSignal`.",
                              "name": "signal",
                              "type": "AbortSignal",
                              "desc": "Optionally allows the `question()` to be canceled using an `AbortSignal`."
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>rl.question()</code> method displays the <code>query</code> by writing it to the <code>output</code>,\nwaits for user input to be provided on <code>input</code>, then invokes the <code>callback</code>\nfunction passing the provided input as the first argument.</p>\n<p>When called, <code>rl.question()</code> will resume the <code>input</code> stream if it has been\npaused.</p>\n<p>If the <code>readlinePromises.Interface</code> was created with <code>output</code> set to <code>null</code> or\n<code>undefined</code> the <code>query</code> is not written.</p>\n<p>If the question is called after <code>rl.close()</code>, it returns a rejected promise.</p>\n<p>Example usage:</p>\n<pre><code class=\"language-mjs\">const answer = await rl.question('What is your favorite food? ');\nconsole.log(`Oh, so your favorite food is ${answer}`);\n</code></pre>\n<p>Using an <code>AbortSignal</code> to cancel a question.</p>\n<pre><code class=\"language-mjs\">const signal = AbortSignal.timeout(10_000);\n\nsignal.addEventListener('abort', () => {\n  console.log('The food question timed out');\n}, { once: true });\n\nconst answer = await rl.question('What is your favorite food? ', { signal });\nconsole.log(`Oh, so your favorite food is ${answer}`);\n</code></pre>"
                }
              ]
            },
            {
              "textRaw": "Class: `readlinePromises.Readline`",
              "type": "class",
              "name": "readlinePromises.Readline",
              "meta": {
                "added": [
                  "v17.0.0"
                ],
                "changes": []
              },
              "methods": [
                {
                  "textRaw": "`rl.clearLine(dir)`",
                  "type": "method",
                  "name": "clearLine",
                  "meta": {
                    "added": [
                      "v17.0.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: this",
                        "name": "return",
                        "desc": "this"
                      },
                      "params": [
                        {
                          "textRaw": "`dir` {integer}",
                          "name": "dir",
                          "type": "integer",
                          "options": [
                            {
                              "textRaw": "`-1`: to the left from cursor",
                              "name": "-1",
                              "desc": "to the left from cursor"
                            },
                            {
                              "textRaw": "`1`: to the right from cursor",
                              "name": "1",
                              "desc": "to the right from cursor"
                            },
                            {
                              "textRaw": "`0`: the entire line",
                              "name": "0",
                              "desc": "the entire line"
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>rl.clearLine()</code> method adds to the internal list of pending action an\naction that clears current line of the associated <code>stream</code> in a specified\ndirection identified by <code>dir</code>.\nCall <code>rl.commit()</code> to see the effect of this method, unless <code>autoCommit: true</code>\nwas passed to the constructor.</p>"
                },
                {
                  "textRaw": "`rl.clearScreenDown()`",
                  "type": "method",
                  "name": "clearScreenDown",
                  "meta": {
                    "added": [
                      "v17.0.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: this",
                        "name": "return",
                        "desc": "this"
                      },
                      "params": []
                    }
                  ],
                  "desc": "<p>The <code>rl.clearScreenDown()</code> method adds to the internal list of pending action an\naction that clears the associated stream from the current position of the\ncursor down.\nCall <code>rl.commit()</code> to see the effect of this method, unless <code>autoCommit: true</code>\nwas passed to the constructor.</p>"
                },
                {
                  "textRaw": "`rl.commit()`",
                  "type": "method",
                  "name": "commit",
                  "meta": {
                    "added": [
                      "v17.0.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {Promise}",
                        "name": "return",
                        "type": "Promise"
                      },
                      "params": []
                    }
                  ],
                  "desc": "<p>The <code>rl.commit()</code> method sends all the pending actions to the associated\n<code>stream</code> and clears the internal list of pending actions.</p>"
                },
                {
                  "textRaw": "`rl.cursorTo(x[, y])`",
                  "type": "method",
                  "name": "cursorTo",
                  "meta": {
                    "added": [
                      "v17.0.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: this",
                        "name": "return",
                        "desc": "this"
                      },
                      "params": [
                        {
                          "textRaw": "`x` {integer}",
                          "name": "x",
                          "type": "integer"
                        },
                        {
                          "textRaw": "`y` {integer}",
                          "name": "y",
                          "type": "integer"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>rl.cursorTo()</code> method adds to the internal list of pending action an action\nthat moves cursor to the specified position in the associated <code>stream</code>.\nCall <code>rl.commit()</code> to see the effect of this method, unless <code>autoCommit: true</code>\nwas passed to the constructor.</p>"
                },
                {
                  "textRaw": "`rl.moveCursor(dx, dy)`",
                  "type": "method",
                  "name": "moveCursor",
                  "meta": {
                    "added": [
                      "v17.0.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: this",
                        "name": "return",
                        "desc": "this"
                      },
                      "params": [
                        {
                          "textRaw": "`dx` {integer}",
                          "name": "dx",
                          "type": "integer"
                        },
                        {
                          "textRaw": "`dy` {integer}",
                          "name": "dy",
                          "type": "integer"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>rl.moveCursor()</code> method adds to the internal list of pending action an\naction that moves the cursor <em>relative</em> to its current position in the\nassociated <code>stream</code>.\nCall <code>rl.commit()</code> to see the effect of this method, unless <code>autoCommit: true</code>\nwas passed to the constructor.</p>"
                },
                {
                  "textRaw": "`rl.rollback()`",
                  "type": "method",
                  "name": "rollback",
                  "meta": {
                    "added": [
                      "v17.0.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: this",
                        "name": "return",
                        "desc": "this"
                      },
                      "params": []
                    }
                  ],
                  "desc": "<p>The <code>rl.rollback</code> methods clears the internal list of pending actions without\nsending it to the associated <code>stream</code>.</p>"
                }
              ],
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`stream` {stream.Writable} A [TTY][] stream.",
                      "name": "stream",
                      "type": "stream.Writable",
                      "desc": "A [TTY][] stream."
                    },
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`autoCommit` {boolean} If `true`, no need to call `rl.commit()`.",
                          "name": "autoCommit",
                          "type": "boolean",
                          "desc": "If `true`, no need to call `rl.commit()`."
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "methods": [
            {
              "textRaw": "`readlinePromises.createInterface(options)`",
              "type": "method",
              "name": "createInterface",
              "meta": {
                "added": [
                  "v17.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {readlinePromises.Interface}",
                    "name": "return",
                    "type": "readlinePromises.Interface"
                  },
                  "params": [
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`input` {stream.Readable} The [Readable][] stream to listen to. This option is _required_.",
                          "name": "input",
                          "type": "stream.Readable",
                          "desc": "The [Readable][] stream to listen to. This option is _required_."
                        },
                        {
                          "textRaw": "`output` {stream.Writable} The [Writable][] stream to write readline data to.",
                          "name": "output",
                          "type": "stream.Writable",
                          "desc": "The [Writable][] stream to write readline data to."
                        },
                        {
                          "textRaw": "`completer` {Function} An optional function used for Tab autocompletion.",
                          "name": "completer",
                          "type": "Function",
                          "desc": "An optional function used for Tab autocompletion."
                        },
                        {
                          "textRaw": "`terminal` {boolean} `true` if the `input` and `output` streams should be treated like a TTY, and have ANSI/VT100 escape codes written to it. **Default:** checking `isTTY` on the `output` stream upon instantiation.",
                          "name": "terminal",
                          "type": "boolean",
                          "default": "checking `isTTY` on the `output` stream upon instantiation",
                          "desc": "`true` if the `input` and `output` streams should be treated like a TTY, and have ANSI/VT100 escape codes written to it."
                        },
                        {
                          "textRaw": "`history` {string\\[]} Initial list of history lines. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all. **Default:** `[]`.",
                          "name": "history",
                          "type": "string\\[]",
                          "default": "`[]`",
                          "desc": "Initial list of history lines. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all."
                        },
                        {
                          "textRaw": "`historySize` {number} Maximum number of history lines retained. To disable the history set this value to `0`. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all. **Default:** `30`.",
                          "name": "historySize",
                          "type": "number",
                          "default": "`30`",
                          "desc": "Maximum number of history lines retained. To disable the history set this value to `0`. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all."
                        },
                        {
                          "textRaw": "`removeHistoryDuplicates` {boolean} If `true`, when a new input line added to the history list duplicates an older one, this removes the older line from the list. **Default:** `false`.",
                          "name": "removeHistoryDuplicates",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If `true`, when a new input line added to the history list duplicates an older one, this removes the older line from the list."
                        },
                        {
                          "textRaw": "`prompt` {string} The prompt string to use. **Default:** `'> '`.",
                          "name": "prompt",
                          "type": "string",
                          "default": "`'> '`",
                          "desc": "The prompt string to use."
                        },
                        {
                          "textRaw": "`crlfDelay` {number} If the delay between `\\r` and `\\n` exceeds `crlfDelay` milliseconds, both `\\r` and `\\n` will be treated as separate end-of-line input. `crlfDelay` will be coerced to a number no less than `100`. It can be set to `Infinity`, in which case `\\r` followed by `\\n` will always be considered a single newline (which may be reasonable for [reading files][] with `\\r\\n` line delimiter). **Default:** `100`.",
                          "name": "crlfDelay",
                          "type": "number",
                          "default": "`100`",
                          "desc": "If the delay between `\\r` and `\\n` exceeds `crlfDelay` milliseconds, both `\\r` and `\\n` will be treated as separate end-of-line input. `crlfDelay` will be coerced to a number no less than `100`. It can be set to `Infinity`, in which case `\\r` followed by `\\n` will always be considered a single newline (which may be reasonable for [reading files][] with `\\r\\n` line delimiter)."
                        },
                        {
                          "textRaw": "`escapeCodeTimeout` {number} The duration `readlinePromises` will wait for a character (when reading an ambiguous key sequence in milliseconds one that can both form a complete key sequence using the input read so far and can take additional input to complete a longer key sequence). **Default:** `500`.",
                          "name": "escapeCodeTimeout",
                          "type": "number",
                          "default": "`500`",
                          "desc": "The duration `readlinePromises` will wait for a character (when reading an ambiguous key sequence in milliseconds one that can both form a complete key sequence using the input read so far and can take additional input to complete a longer key sequence)."
                        },
                        {
                          "textRaw": "`tabSize` {integer} The number of spaces a tab is equal to (minimum 1). **Default:** `8`.",
                          "name": "tabSize",
                          "type": "integer",
                          "default": "`8`",
                          "desc": "The number of spaces a tab is equal to (minimum 1)."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>readlinePromises.createInterface()</code> method creates a new <code>readlinePromises.Interface</code>\ninstance.</p>\n<pre><code class=\"language-js\">const readlinePromises = require('node:readline/promises');\nconst rl = readlinePromises.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n</code></pre>\n<p>Once the <code>readlinePromises.Interface</code> instance is created, the most common case\nis to listen for the <code>'line'</code> event:</p>\n<pre><code class=\"language-js\">rl.on('line', (line) => {\n  console.log(`Received: ${line}`);\n});\n</code></pre>\n<p>If <code>terminal</code> is <code>true</code> for this instance then the <code>output</code> stream will get\nthe best compatibility if it defines an <code>output.columns</code> property and emits\na <code>'resize'</code> event on the <code>output</code> if or when the columns ever change\n(<a href=\"process.html#processstdout\"><code>process.stdout</code></a> does this automatically when it is a TTY).</p>",
              "modules": [
                {
                  "textRaw": "Use of the `completer` function",
                  "name": "use_of_the_`completer`_function",
                  "desc": "<p>The <code>completer</code> function takes the current line entered by the user\nas an argument, and returns an <code>Array</code> with 2 entries:</p>\n<ul>\n<li>An <code>Array</code> with matching entries for the completion.</li>\n<li>The substring that was used for the matching.</li>\n</ul>\n<p>For instance: <code>[[substr1, substr2, ...], originalsubstring]</code>.</p>\n<pre><code class=\"language-js\">function completer(line) {\n  const completions = '.help .error .exit .quit .q'.split(' ');\n  const hits = completions.filter((c) => c.startsWith(line));\n  // Show all completions if none found\n  return [hits.length ? hits : completions, line];\n}\n</code></pre>\n<p>The <code>completer</code> function can also returns a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" class=\"type\">&lt;Promise&gt;</a>, or be asynchronous:</p>\n<pre><code class=\"language-js\">async function completer(linePartial) {\n  await someAsyncWork();\n  return [['123'], linePartial];\n}\n</code></pre>",
                  "type": "module",
                  "displayName": "Use of the `completer` function"
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "Promises API"
        },
        {
          "textRaw": "Callback API",
          "name": "callback_api",
          "meta": {
            "added": [
              "v0.1.104"
            ],
            "changes": []
          },
          "classes": [
            {
              "textRaw": "Class: `readline.Interface`",
              "type": "class",
              "name": "readline.Interface",
              "meta": {
                "added": [
                  "v0.1.104"
                ],
                "changes": [
                  {
                    "version": "v17.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/37947",
                    "description": "The class `readline.Interface` now inherits from `Interface`."
                  }
                ]
              },
              "desc": "<ul>\n<li>Extends: <a href=\"readline.html#class-interfaceconstructor\" class=\"type\">&lt;readline.InterfaceConstructor&gt;</a></li>\n</ul>\n<p>Instances of the <code>readline.Interface</code> class are constructed using the\n<code>readline.createInterface()</code> method. Every instance is associated with a\nsingle <code>input</code> <a href=\"stream.html#readable-streams\">Readable</a> stream and a single <code>output</code> <a href=\"stream.html#writable-streams\">Writable</a> stream.\nThe <code>output</code> stream is used to print prompts for user input that arrives on,\nand is read from, the <code>input</code> stream.</p>",
              "methods": [
                {
                  "textRaw": "`rl.question(query[, options], callback)`",
                  "type": "method",
                  "name": "question",
                  "meta": {
                    "added": [
                      "v0.3.3"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`query` {string} A statement or query to write to `output`, prepended to the prompt.",
                          "name": "query",
                          "type": "string",
                          "desc": "A statement or query to write to `output`, prepended to the prompt."
                        },
                        {
                          "textRaw": "`options` {Object}",
                          "name": "options",
                          "type": "Object",
                          "options": [
                            {
                              "textRaw": "`signal` {AbortSignal} Optionally allows the `question()` to be canceled using an `AbortController`.",
                              "name": "signal",
                              "type": "AbortSignal",
                              "desc": "Optionally allows the `question()` to be canceled using an `AbortController`."
                            }
                          ]
                        },
                        {
                          "textRaw": "`callback` {Function} A callback function that is invoked with the user's input in response to the `query`.",
                          "name": "callback",
                          "type": "Function",
                          "desc": "A callback function that is invoked with the user's input in response to the `query`."
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>rl.question()</code> method displays the <code>query</code> by writing it to the <code>output</code>,\nwaits for user input to be provided on <code>input</code>, then invokes the <code>callback</code>\nfunction passing the provided input as the first argument.</p>\n<p>When called, <code>rl.question()</code> will resume the <code>input</code> stream if it has been\npaused.</p>\n<p>If the <code>readline.Interface</code> was created with <code>output</code> set to <code>null</code> or\n<code>undefined</code> the <code>query</code> is not written.</p>\n<p>The <code>callback</code> function passed to <code>rl.question()</code> does not follow the typical\npattern of accepting an <code>Error</code> object or <code>null</code> as the first argument.\nThe <code>callback</code> is called with the provided answer as the only argument.</p>\n<p>An error will be thrown if calling <code>rl.question()</code> after <code>rl.close()</code>.</p>\n<p>Example usage:</p>\n<pre><code class=\"language-js\">rl.question('What is your favorite food? ', (answer) => {\n  console.log(`Oh, so your favorite food is ${answer}`);\n});\n</code></pre>\n<p>Using an <code>AbortController</code> to cancel a question.</p>\n<pre><code class=\"language-js\">const ac = new AbortController();\nconst signal = ac.signal;\n\nrl.question('What is your favorite food? ', { signal }, (answer) => {\n  console.log(`Oh, so your favorite food is ${answer}`);\n});\n\nsignal.addEventListener('abort', () => {\n  console.log('The food question timed out');\n}, { once: true });\n\nsetTimeout(() => ac.abort(), 10000);\n</code></pre>"
                }
              ]
            }
          ],
          "methods": [
            {
              "textRaw": "`readline.clearLine(stream, dir[, callback])`",
              "type": "method",
              "name": "clearLine",
              "meta": {
                "added": [
                  "v0.7.7"
                ],
                "changes": [
                  {
                    "version": "v18.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/41678",
                    "description": "Passing an invalid callback to the `callback` argument now throws `ERR_INVALID_ARG_TYPE` instead of `ERR_INVALID_CALLBACK`."
                  },
                  {
                    "version": "v12.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/28674",
                    "description": "The stream's write() callback and return value are exposed."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.",
                    "name": "return",
                    "type": "boolean",
                    "desc": "`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`."
                  },
                  "params": [
                    {
                      "textRaw": "`stream` {stream.Writable}",
                      "name": "stream",
                      "type": "stream.Writable"
                    },
                    {
                      "textRaw": "`dir` {number}",
                      "name": "dir",
                      "type": "number",
                      "options": [
                        {
                          "textRaw": "`-1`: to the left from cursor",
                          "name": "-1",
                          "desc": "to the left from cursor"
                        },
                        {
                          "textRaw": "`1`: to the right from cursor",
                          "name": "1",
                          "desc": "to the right from cursor"
                        },
                        {
                          "textRaw": "`0`: the entire line",
                          "name": "0",
                          "desc": "the entire line"
                        }
                      ]
                    },
                    {
                      "textRaw": "`callback` {Function} Invoked once the operation completes.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Invoked once the operation completes."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>readline.clearLine()</code> method clears current line of given <a href=\"tty.html\">TTY</a> stream\nin a specified direction identified by <code>dir</code>.</p>"
            },
            {
              "textRaw": "`readline.clearScreenDown(stream[, callback])`",
              "type": "method",
              "name": "clearScreenDown",
              "meta": {
                "added": [
                  "v0.7.7"
                ],
                "changes": [
                  {
                    "version": "v18.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/41678",
                    "description": "Passing an invalid callback to the `callback` argument now throws `ERR_INVALID_ARG_TYPE` instead of `ERR_INVALID_CALLBACK`."
                  },
                  {
                    "version": "v12.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/28641",
                    "description": "The stream's write() callback and return value are exposed."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.",
                    "name": "return",
                    "type": "boolean",
                    "desc": "`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`."
                  },
                  "params": [
                    {
                      "textRaw": "`stream` {stream.Writable}",
                      "name": "stream",
                      "type": "stream.Writable"
                    },
                    {
                      "textRaw": "`callback` {Function} Invoked once the operation completes.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Invoked once the operation completes."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>readline.clearScreenDown()</code> method clears the given <a href=\"tty.html\">TTY</a> stream from\nthe current position of the cursor down.</p>"
            },
            {
              "textRaw": "`readline.createInterface(options)`",
              "type": "method",
              "name": "createInterface",
              "meta": {
                "added": [
                  "v0.1.98"
                ],
                "changes": [
                  {
                    "version": [
                      "v15.14.0",
                      "v14.18.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/37932",
                    "description": "The `signal` option is supported now."
                  },
                  {
                    "version": [
                      "v15.8.0",
                      "v14.18.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/33662",
                    "description": "The `history` option is supported now."
                  },
                  {
                    "version": "v13.9.0",
                    "pr-url": "https://github.com/nodejs/node/pull/31318",
                    "description": "The `tabSize` option is supported now."
                  },
                  {
                    "version": [
                      "v8.3.0",
                      "v6.11.4"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/13497",
                    "description": "Remove max limit of `crlfDelay` option."
                  },
                  {
                    "version": "v6.6.0",
                    "pr-url": "https://github.com/nodejs/node/pull/8109",
                    "description": "The `crlfDelay` option is supported now."
                  },
                  {
                    "version": "v6.3.0",
                    "pr-url": "https://github.com/nodejs/node/pull/7125",
                    "description": "The `prompt` option is supported now."
                  },
                  {
                    "version": "v6.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/6352",
                    "description": "The `historySize` option can be `0` now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {readline.Interface}",
                    "name": "return",
                    "type": "readline.Interface"
                  },
                  "params": [
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`input` {stream.Readable} The [Readable][] stream to listen to. This option is _required_.",
                          "name": "input",
                          "type": "stream.Readable",
                          "desc": "The [Readable][] stream to listen to. This option is _required_."
                        },
                        {
                          "textRaw": "`output` {stream.Writable} The [Writable][] stream to write readline data to.",
                          "name": "output",
                          "type": "stream.Writable",
                          "desc": "The [Writable][] stream to write readline data to."
                        },
                        {
                          "textRaw": "`completer` {Function} An optional function used for Tab autocompletion.",
                          "name": "completer",
                          "type": "Function",
                          "desc": "An optional function used for Tab autocompletion."
                        },
                        {
                          "textRaw": "`terminal` {boolean} `true` if the `input` and `output` streams should be treated like a TTY, and have ANSI/VT100 escape codes written to it. **Default:** checking `isTTY` on the `output` stream upon instantiation.",
                          "name": "terminal",
                          "type": "boolean",
                          "default": "checking `isTTY` on the `output` stream upon instantiation",
                          "desc": "`true` if the `input` and `output` streams should be treated like a TTY, and have ANSI/VT100 escape codes written to it."
                        },
                        {
                          "textRaw": "`history` {string\\[]} Initial list of history lines. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all. **Default:** `[]`.",
                          "name": "history",
                          "type": "string\\[]",
                          "default": "`[]`",
                          "desc": "Initial list of history lines. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all."
                        },
                        {
                          "textRaw": "`historySize` {number} Maximum number of history lines retained. To disable the history set this value to `0`. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all. **Default:** `30`.",
                          "name": "historySize",
                          "type": "number",
                          "default": "`30`",
                          "desc": "Maximum number of history lines retained. To disable the history set this value to `0`. This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check, otherwise the history caching mechanism is not initialized at all."
                        },
                        {
                          "textRaw": "`removeHistoryDuplicates` {boolean} If `true`, when a new input line added to the history list duplicates an older one, this removes the older line from the list. **Default:** `false`.",
                          "name": "removeHistoryDuplicates",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If `true`, when a new input line added to the history list duplicates an older one, this removes the older line from the list."
                        },
                        {
                          "textRaw": "`prompt` {string} The prompt string to use. **Default:** `'> '`.",
                          "name": "prompt",
                          "type": "string",
                          "default": "`'> '`",
                          "desc": "The prompt string to use."
                        },
                        {
                          "textRaw": "`crlfDelay` {number} If the delay between `\\r` and `\\n` exceeds `crlfDelay` milliseconds, both `\\r` and `\\n` will be treated as separate end-of-line input. `crlfDelay` will be coerced to a number no less than `100`. It can be set to `Infinity`, in which case `\\r` followed by `\\n` will always be considered a single newline (which may be reasonable for [reading files][] with `\\r\\n` line delimiter). **Default:** `100`.",
                          "name": "crlfDelay",
                          "type": "number",
                          "default": "`100`",
                          "desc": "If the delay between `\\r` and `\\n` exceeds `crlfDelay` milliseconds, both `\\r` and `\\n` will be treated as separate end-of-line input. `crlfDelay` will be coerced to a number no less than `100`. It can be set to `Infinity`, in which case `\\r` followed by `\\n` will always be considered a single newline (which may be reasonable for [reading files][] with `\\r\\n` line delimiter)."
                        },
                        {
                          "textRaw": "`escapeCodeTimeout` {number} The duration `readline` will wait for a character (when reading an ambiguous key sequence in milliseconds one that can both form a complete key sequence using the input read so far and can take additional input to complete a longer key sequence). **Default:** `500`.",
                          "name": "escapeCodeTimeout",
                          "type": "number",
                          "default": "`500`",
                          "desc": "The duration `readline` will wait for a character (when reading an ambiguous key sequence in milliseconds one that can both form a complete key sequence using the input read so far and can take additional input to complete a longer key sequence)."
                        },
                        {
                          "textRaw": "`tabSize` {integer} The number of spaces a tab is equal to (minimum 1). **Default:** `8`.",
                          "name": "tabSize",
                          "type": "integer",
                          "default": "`8`",
                          "desc": "The number of spaces a tab is equal to (minimum 1)."
                        },
                        {
                          "textRaw": "`signal` {AbortSignal} Allows closing the interface using an AbortSignal. Aborting the signal will internally call `close` on the interface.",
                          "name": "signal",
                          "type": "AbortSignal",
                          "desc": "Allows closing the interface using an AbortSignal. Aborting the signal will internally call `close` on the interface."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>readline.createInterface()</code> method creates a new <code>readline.Interface</code>\ninstance.</p>\n<pre><code class=\"language-js\">const readline = require('node:readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n</code></pre>\n<p>Once the <code>readline.Interface</code> instance is created, the most common case is to\nlisten for the <code>'line'</code> event:</p>\n<pre><code class=\"language-js\">rl.on('line', (line) => {\n  console.log(`Received: ${line}`);\n});\n</code></pre>\n<p>If <code>terminal</code> is <code>true</code> for this instance then the <code>output</code> stream will get\nthe best compatibility if it defines an <code>output.columns</code> property and emits\na <code>'resize'</code> event on the <code>output</code> if or when the columns ever change\n(<a href=\"process.html#processstdout\"><code>process.stdout</code></a> does this automatically when it is a TTY).</p>\n<p>When creating a <code>readline.Interface</code> using <code>stdin</code> as input, the program\nwill not terminate until it receives an <a href=\"https://en.wikipedia.org/wiki/End-of-file#EOF_character\">EOF character</a>. To exit without\nwaiting for user input, call <code>process.stdin.unref()</code>.</p>",
              "modules": [
                {
                  "textRaw": "Use of the `completer` function",
                  "name": "use_of_the_`completer`_function",
                  "desc": "<p>The <code>completer</code> function takes the current line entered by the user\nas an argument, and returns an <code>Array</code> with 2 entries:</p>\n<ul>\n<li>An <code>Array</code> with matching entries for the completion.</li>\n<li>The substring that was used for the matching.</li>\n</ul>\n<p>For instance: <code>[[substr1, substr2, ...], originalsubstring]</code>.</p>\n<pre><code class=\"language-js\">function completer(line) {\n  const completions = '.help .error .exit .quit .q'.split(' ');\n  const hits = completions.filter((c) => c.startsWith(line));\n  // Show all completions if none found\n  return [hits.length ? hits : completions, line];\n}\n</code></pre>\n<p>The <code>completer</code> function can be called asynchronously if it accepts two\narguments:</p>\n<pre><code class=\"language-js\">function completer(linePartial, callback) {\n  callback(null, [['123'], linePartial]);\n}\n</code></pre>",
                  "type": "module",
                  "displayName": "Use of the `completer` function"
                }
              ]
            },
            {
              "textRaw": "`readline.cursorTo(stream, x[, y][, callback])`",
              "type": "method",
              "name": "cursorTo",
              "meta": {
                "added": [
                  "v0.7.7"
                ],
                "changes": [
                  {
                    "version": "v18.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/41678",
                    "description": "Passing an invalid callback to the `callback` argument now throws `ERR_INVALID_ARG_TYPE` instead of `ERR_INVALID_CALLBACK`."
                  },
                  {
                    "version": "v12.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/28674",
                    "description": "The stream's write() callback and return value are exposed."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.",
                    "name": "return",
                    "type": "boolean",
                    "desc": "`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`."
                  },
                  "params": [
                    {
                      "textRaw": "`stream` {stream.Writable}",
                      "name": "stream",
                      "type": "stream.Writable"
                    },
                    {
                      "textRaw": "`x` {number}",
                      "name": "x",
                      "type": "number"
                    },
                    {
                      "textRaw": "`y` {number}",
                      "name": "y",
                      "type": "number"
                    },
                    {
                      "textRaw": "`callback` {Function} Invoked once the operation completes.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Invoked once the operation completes."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>readline.cursorTo()</code> method moves cursor to the specified position in a\ngiven <a href=\"tty.html\">TTY</a> <code>stream</code>.</p>"
            },
            {
              "textRaw": "`readline.moveCursor(stream, dx, dy[, callback])`",
              "type": "method",
              "name": "moveCursor",
              "meta": {
                "added": [
                  "v0.7.7"
                ],
                "changes": [
                  {
                    "version": "v18.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/41678",
                    "description": "Passing an invalid callback to the `callback` argument now throws `ERR_INVALID_ARG_TYPE` instead of `ERR_INVALID_CALLBACK`."
                  },
                  {
                    "version": "v12.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/28674",
                    "description": "The stream's write() callback and return value are exposed."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.",
                    "name": "return",
                    "type": "boolean",
                    "desc": "`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`."
                  },
                  "params": [
                    {
                      "textRaw": "`stream` {stream.Writable}",
                      "name": "stream",
                      "type": "stream.Writable"
                    },
                    {
                      "textRaw": "`dx` {number}",
                      "name": "dx",
                      "type": "number"
                    },
                    {
                      "textRaw": "`dy` {number}",
                      "name": "dy",
                      "type": "number"
                    },
                    {
                      "textRaw": "`callback` {Function} Invoked once the operation completes.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Invoked once the operation completes."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>readline.moveCursor()</code> method moves the cursor <em>relative</em> to its current\nposition in a given <a href=\"tty.html\">TTY</a> <code>stream</code>.</p>"
            }
          ],
          "type": "module",
          "displayName": "Callback API"
        },
        {
          "textRaw": "TTY keybindings",
          "name": "tty_keybindings",
          "desc": "<table>\n  <tr>\n    <th>Keybindings</th>\n    <th>Description</th>\n    <th>Notes</th>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Backspace</kbd></td>\n    <td>Delete line left</td>\n    <td>Doesn't work on Linux, Mac and Windows</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Delete</kbd></td>\n    <td>Delete line right</td>\n    <td>Doesn't work on Mac</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>C</kbd></td>\n    <td>Emit <code>SIGINT</code> or close the readline instance</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>H</kbd></td>\n    <td>Delete left</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>D</kbd></td>\n    <td>Delete right or close the readline instance in case the current line is empty / EOF</td>\n    <td>Doesn't work on Windows</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>U</kbd></td>\n    <td>Delete from the current position to the line start</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>K</kbd></td>\n    <td>Delete from the current position to the end of line</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>Y</kbd></td>\n    <td>Yank (Recall) the previously deleted text</td>\n    <td>Only works with text deleted by <kbd>Ctrl</kbd>+<kbd>U</kbd> or <kbd>Ctrl</kbd>+<kbd>K</kbd></td>\n  </tr>\n  <tr>\n    <td><kbd>Meta</kbd>+<kbd>Y</kbd></td>\n    <td>Cycle among previously deleted lines</td>\n    <td>Only available when the last keystroke is <kbd>Ctrl</kbd>+<kbd>Y</kbd></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>A</kbd></td>\n    <td>Go to start of line</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>E</kbd></td>\n    <td>Go to end of line</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>B</kbd></td>\n    <td>Back one character</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>F</kbd></td>\n    <td>Forward one character</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>L</kbd></td>\n    <td>Clear screen</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>N</kbd></td>\n    <td>Next history item</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>P</kbd></td>\n    <td>Previous history item</td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>-</kbd></td>\n    <td>Undo previous change</td>\n    <td>Any keystroke that emits key code <code>0x1F</code> will do this action.\n    In many terminals, for example <code>xterm</code>,\n    this is bound to <kbd>Ctrl</kbd>+<kbd>-</kbd>.</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>6</kbd></td>\n    <td>Redo previous change</td>\n    <td>Many terminals don't have a default redo keystroke.\n    We choose key code <code>0x1E</code> to perform redo.\n    In <code>xterm</code>, it is bound to <kbd>Ctrl</kbd>+<kbd>6</kbd>\n    by default.</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>Z</kbd></td>\n    <td>Moves running process into background. Type\n    <code>fg</code> and press <kbd>Enter</kbd>\n    to return.</td>\n    <td>Doesn't work on Windows</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>W</kbd> or <kbd>Ctrl</kbd>\n   +<kbd>Backspace</kbd></td>\n    <td>Delete backward to a word boundary</td>\n    <td><kbd>Ctrl</kbd>+<kbd>Backspace</kbd> Doesn't\n    work on Linux, Mac and Windows</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>Delete</kbd></td>\n    <td>Delete forward to a word boundary</td>\n    <td>Doesn't work on Mac</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>Left arrow</kbd> or\n    <kbd>Meta</kbd>+<kbd>B</kbd></td>\n    <td>Word left</td>\n    <td><kbd>Ctrl</kbd>+<kbd>Left arrow</kbd> Doesn't work\n    on Mac</td>\n  </tr>\n  <tr>\n    <td><kbd>Ctrl</kbd>+<kbd>Right arrow</kbd> or\n    <kbd>Meta</kbd>+<kbd>F</kbd></td>\n    <td>Word right</td>\n    <td><kbd>Ctrl</kbd>+<kbd>Right arrow</kbd> Doesn't work\n    on Mac</td>\n  </tr>\n  <tr>\n    <td><kbd>Meta</kbd>+<kbd>D</kbd> or <kbd>Meta</kbd>\n   +<kbd>Delete</kbd></td>\n    <td>Delete word right</td>\n    <td><kbd>Meta</kbd>+<kbd>Delete</kbd> Doesn't work\n    on windows</td>\n  </tr>\n  <tr>\n    <td><kbd>Meta</kbd>+<kbd>Backspace</kbd></td>\n    <td>Delete word left</td>\n    <td>Doesn't work on Mac</td>\n  </tr>\n</table>",
          "type": "module",
          "displayName": "TTY keybindings"
        }
      ],
      "methods": [
        {
          "textRaw": "`readline.emitKeypressEvents(stream[, interface])`",
          "type": "method",
          "name": "emitKeypressEvents",
          "meta": {
            "added": [
              "v0.7.7"
            ],
            "changes": []
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`stream` {stream.Readable}",
                  "name": "stream",
                  "type": "stream.Readable"
                },
                {
                  "textRaw": "`interface` {readline.InterfaceConstructor}",
                  "name": "interface",
                  "type": "readline.InterfaceConstructor"
                }
              ]
            }
          ],
          "desc": "<p>The <code>readline.emitKeypressEvents()</code> method causes the given <a href=\"stream.html#readable-streams\">Readable</a>\nstream to begin emitting <code>'keypress'</code> events corresponding to received input.</p>\n<p>Optionally, <code>interface</code> specifies a <code>readline.Interface</code> instance for which\nautocompletion is disabled when copy-pasted input is detected.</p>\n<p>If the <code>stream</code> is a <a href=\"tty.html\">TTY</a>, then it must be in raw mode.</p>\n<p>This is automatically called by any readline instance on its <code>input</code> if the\n<code>input</code> is a terminal. Closing the <code>readline</code> instance does not stop\nthe <code>input</code> from emitting <code>'keypress'</code> events.</p>\n<pre><code class=\"language-js\">readline.emitKeypressEvents(process.stdin);\nif (process.stdin.isTTY)\n  process.stdin.setRawMode(true);\n</code></pre>\n<h2>Example: Tiny CLI</h2>\n<p>The following example illustrates the use of <code>readline.Interface</code> class to\nimplement a small command-line interface:</p>\n<pre><code class=\"language-js\">const readline = require('node:readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n  prompt: 'OHAI> ',\n});\n\nrl.prompt();\n\nrl.on('line', (line) => {\n  switch (line.trim()) {\n    case 'hello':\n      console.log('world!');\n      break;\n    default:\n      console.log(`Say what? I might have heard '${line.trim()}'`);\n      break;\n  }\n  rl.prompt();\n}).on('close', () => {\n  console.log('Have a great day!');\n  process.exit(0);\n});\n</code></pre>\n<h2>Example: Read file stream line-by-Line</h2>\n<p>A common use case for <code>readline</code> is to consume an input file one line at a\ntime. The easiest way to do so is leveraging the <a href=\"fs.html#class-fsreadstream\"><code>fs.ReadStream</code></a> API as\nwell as a <code>for await...of</code> loop:</p>\n<pre><code class=\"language-js\">const fs = require('node:fs');\nconst readline = require('node:readline');\n\nasync function processLineByLine() {\n  const fileStream = fs.createReadStream('input.txt');\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity,\n  });\n  // Note: we use the crlfDelay option to recognize all instances of CR LF\n  // ('\\r\\n') in input.txt as a single line break.\n\n  for await (const line of rl) {\n    // Each line in input.txt will be successively available here as `line`.\n    console.log(`Line from file: ${line}`);\n  }\n}\n\nprocessLineByLine();\n</code></pre>\n<p>Alternatively, one could use the <a href=\"#event-line\"><code>'line'</code></a> event:</p>\n<pre><code class=\"language-js\">const fs = require('node:fs');\nconst readline = require('node:readline');\n\nconst rl = readline.createInterface({\n  input: fs.createReadStream('sample.txt'),\n  crlfDelay: Infinity,\n});\n\nrl.on('line', (line) => {\n  console.log(`Line from file: ${line}`);\n});\n</code></pre>\n<p>Currently, <code>for await...of</code> loop can be a bit slower. If <code>async</code> / <code>await</code>\nflow and speed are both essential, a mixed approach can be applied:</p>\n<pre><code class=\"language-js\">const { once } = require('node:events');\nconst { createReadStream } = require('node:fs');\nconst { createInterface } = require('node:readline');\n\n(async function processLineByLine() {\n  try {\n    const rl = createInterface({\n      input: createReadStream('big-file.txt'),\n      crlfDelay: Infinity,\n    });\n\n    rl.on('line', (line) => {\n      // Process the line.\n    });\n\n    await once(rl, 'close');\n\n    console.log('File processed.');\n  } catch (err) {\n    console.error(err);\n  }\n})();\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "Readline"
    }
  ]
}