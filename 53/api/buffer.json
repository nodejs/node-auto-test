{
  "type": "module",
  "source": "doc/api/buffer.md",
  "modules": [
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "introduced_in": "v0.1.90",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p><strong>Source Code:</strong> <a href=\"https://github.com/nodejs/node/blob/v20.0.0/lib/buffer.js\">lib/buffer.js</a></p>\n<p><code>Buffer</code> objects are used to represent a fixed-length sequence of bytes. Many\nNode.js APIs support <code>Buffer</code>s.</p>\n<p>The <code>Buffer</code> class is a subclass of JavaScript's <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> class and\nextends it with methods that cover additional use cases. Node.js APIs accept\nplain <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a>s wherever <code>Buffer</code>s are supported as well.</p>\n<p>While the <code>Buffer</code> class is available within the global scope, it is still\nrecommended to explicitly reference it via an import or require statement.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Creates a zero-filled Buffer of length 10.\nconst buf1 = Buffer.alloc(10);\n\n// Creates a Buffer of length 10,\n// filled with bytes which all have the value `1`.\nconst buf2 = Buffer.alloc(10, 1);\n\n// Creates an uninitialized buffer of length 10.\n// This is faster than calling Buffer.alloc() but the returned\n// Buffer instance might contain old data that needs to be\n// overwritten using fill(), write(), or other functions that fill the Buffer's\n// contents.\nconst buf3 = Buffer.allocUnsafe(10);\n\n// Creates a Buffer containing the bytes [1, 2, 3].\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries\n// are all truncated using `(value &#x26; 255)` to fit into the range 0–255.\nconst buf5 = Buffer.from([257, 257.5, -255, '1']);\n\n// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':\n// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)\n// [116, 195, 169, 115, 116] (in decimal notation)\nconst buf6 = Buffer.from('tést');\n\n// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].\nconst buf7 = Buffer.from('tést', 'latin1');\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Creates a zero-filled Buffer of length 10.\nconst buf1 = Buffer.alloc(10);\n\n// Creates a Buffer of length 10,\n// filled with bytes which all have the value `1`.\nconst buf2 = Buffer.alloc(10, 1);\n\n// Creates an uninitialized buffer of length 10.\n// This is faster than calling Buffer.alloc() but the returned\n// Buffer instance might contain old data that needs to be\n// overwritten using fill(), write(), or other functions that fill the Buffer's\n// contents.\nconst buf3 = Buffer.allocUnsafe(10);\n\n// Creates a Buffer containing the bytes [1, 2, 3].\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries\n// are all truncated using `(value &#x26; 255)` to fit into the range 0–255.\nconst buf5 = Buffer.from([257, 257.5, -255, '1']);\n\n// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':\n// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)\n// [116, 195, 169, 115, 116] (in decimal notation)\nconst buf6 = Buffer.from('tést');\n\n// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].\nconst buf7 = Buffer.from('tést', 'latin1');\n</code></pre>",
      "modules": [
        {
          "textRaw": "Buffers and character encodings",
          "name": "buffers_and_character_encodings",
          "meta": {
            "changes": [
              {
                "version": [
                  "v15.7.0",
                  "v14.18.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/36952",
                "description": "Introduced `base64url` encoding."
              },
              {
                "version": "v6.4.0",
                "pr-url": "https://github.com/nodejs/node/pull/7111",
                "description": "Introduced `latin1` as an alias for `binary`."
              },
              {
                "version": "v5.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2859",
                "description": "Removed the deprecated `raw` and `raws` encodings."
              }
            ]
          },
          "desc": "<p>When converting between <code>Buffer</code>s and strings, a character encoding may be\nspecified. If no character encoding is specified, UTF-8 will be used as the\ndefault.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('hello world', 'utf8');\n\nconsole.log(buf.toString('hex'));\n// Prints: 68656c6c6f20776f726c64\nconsole.log(buf.toString('base64'));\n// Prints: aGVsbG8gd29ybGQ=\n\nconsole.log(Buffer.from('fhqwhgads', 'utf8'));\n// Prints: &#x3C;Buffer 66 68 71 77 68 67 61 64 73>\nconsole.log(Buffer.from('fhqwhgads', 'utf16le'));\n// Prints: &#x3C;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('hello world', 'utf8');\n\nconsole.log(buf.toString('hex'));\n// Prints: 68656c6c6f20776f726c64\nconsole.log(buf.toString('base64'));\n// Prints: aGVsbG8gd29ybGQ=\n\nconsole.log(Buffer.from('fhqwhgads', 'utf8'));\n// Prints: &#x3C;Buffer 66 68 71 77 68 67 61 64 73>\nconsole.log(Buffer.from('fhqwhgads', 'utf16le'));\n// Prints: &#x3C;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00>\n</code></pre>\n<p>Node.js buffers accept all case variations of encoding strings that they\nreceive. For example, UTF-8 can be specified as <code>'utf8'</code>, <code>'UTF8'</code>, or <code>'uTf8'</code>.</p>\n<p>The character encodings currently supported by Node.js are the following:</p>\n<ul>\n<li>\n<p><code>'utf8'</code> (alias: <code>'utf-8'</code>): Multi-byte encoded Unicode characters. Many web\npages and other document formats use <a href=\"https://en.wikipedia.org/wiki/UTF-8\">UTF-8</a>. This is the default character\nencoding. When decoding a <code>Buffer</code> into a string that does not exclusively\ncontain valid UTF-8 data, the Unicode replacement character <code>U+FFFD</code> � will be\nused to represent those errors.</p>\n</li>\n<li>\n<p><code>'utf16le'</code> (alias: <code>'utf-16le'</code>): Multi-byte encoded Unicode characters.\nUnlike <code>'utf8'</code>, each character in the string will be encoded using either 2\nor 4 bytes. Node.js only supports the <a href=\"https://en.wikipedia.org/wiki/Endianness\">little-endian</a> variant of\n<a href=\"https://en.wikipedia.org/wiki/UTF-16\">UTF-16</a>.</p>\n</li>\n<li>\n<p><code>'latin1'</code>: Latin-1 stands for <a href=\"https://en.wikipedia.org/wiki/ISO-8859-1\">ISO-8859-1</a>. This character encoding only\nsupports the Unicode characters from <code>U+0000</code> to <code>U+00FF</code>. Each character is\nencoded using a single byte. Characters that do not fit into that range are\ntruncated and will be mapped to characters in that range.</p>\n</li>\n</ul>\n<p>Converting a <code>Buffer</code> into a string using one of the above is referred to as\ndecoding, and converting a string into a <code>Buffer</code> is referred to as encoding.</p>\n<p>Node.js also supports the following binary-to-text encodings. For\nbinary-to-text encodings, the naming convention is reversed: Converting a\n<code>Buffer</code> into a string is typically referred to as encoding, and converting a\nstring into a <code>Buffer</code> as decoding.</p>\n<ul>\n<li>\n<p><code>'base64'</code>: <a href=\"https://en.wikipedia.org/wiki/Base64\">Base64</a> encoding. When creating a <code>Buffer</code> from a string,\nthis encoding will also correctly accept \"URL and Filename Safe Alphabet\" as\nspecified in <a href=\"https://tools.ietf.org/html/rfc4648#section-5\">RFC 4648, Section 5</a>. Whitespace characters such as spaces,\ntabs, and new lines contained within the base64-encoded string are ignored.</p>\n</li>\n<li>\n<p><code>'base64url'</code>: <a href=\"https://tools.ietf.org/html/rfc4648#section-5\">base64url</a> encoding as specified in\n<a href=\"https://tools.ietf.org/html/rfc4648#section-5\">RFC 4648, Section 5</a>. When creating a <code>Buffer</code> from a string, this\nencoding will also correctly accept regular base64-encoded strings. When\nencoding a <code>Buffer</code> to a string, this encoding will omit padding.</p>\n</li>\n<li>\n<p><code>'hex'</code>: Encode each byte as two hexadecimal characters. Data truncation\nmay occur when decoding strings that do not exclusively consist of an even\nnumber of hexadecimal characters. See below for an example.</p>\n</li>\n</ul>\n<p>The following legacy character encodings are also supported:</p>\n<ul>\n<li>\n<p><code>'ascii'</code>: For 7-bit <a href=\"https://en.wikipedia.org/wiki/ASCII\">ASCII</a> data only. When encoding a string into a\n<code>Buffer</code>, this is equivalent to using <code>'latin1'</code>. When decoding a <code>Buffer</code>\ninto a string, using this encoding will additionally unset the highest bit of\neach byte before decoding as <code>'latin1'</code>.\nGenerally, there should be no reason to use this encoding, as <code>'utf8'</code>\n(or, if the data is known to always be ASCII-only, <code>'latin1'</code>) will be a\nbetter choice when encoding or decoding ASCII-only text. It is only provided\nfor legacy compatibility.</p>\n</li>\n<li>\n<p><code>'binary'</code>: Alias for <code>'latin1'</code>. See <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DOMString/Binary\">binary strings</a> for more background\non this topic. The name of this encoding can be very misleading, as all of the\nencodings listed here convert between strings and binary data. For converting\nbetween strings and <code>Buffer</code>s, typically <code>'utf8'</code> is the right choice.</p>\n</li>\n<li>\n<p><code>'ucs2'</code>, <code>'ucs-2'</code>: Aliases of <code>'utf16le'</code>. UCS-2 used to refer to a variant\nof UTF-16 that did not support characters that had code points larger than\nU+FFFF. In Node.js, these code points are always supported.</p>\n</li>\n</ul>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nBuffer.from('1ag123', 'hex');\n// Prints &#x3C;Buffer 1a>, data truncated when first non-hexadecimal value\n// ('g') encountered.\n\nBuffer.from('1a7', 'hex');\n// Prints &#x3C;Buffer 1a>, data truncated when data ends in single digit ('7').\n\nBuffer.from('1634', 'hex');\n// Prints &#x3C;Buffer 16 34>, all data represented.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nBuffer.from('1ag123', 'hex');\n// Prints &#x3C;Buffer 1a>, data truncated when first non-hexadecimal value\n// ('g') encountered.\n\nBuffer.from('1a7', 'hex');\n// Prints &#x3C;Buffer 1a>, data truncated when data ends in single digit ('7').\n\nBuffer.from('1634', 'hex');\n// Prints &#x3C;Buffer 16 34>, all data represented.\n</code></pre>\n<p>Modern Web browsers follow the <a href=\"https://encoding.spec.whatwg.org/\">WHATWG Encoding Standard</a> which aliases\nboth <code>'latin1'</code> and <code>'ISO-8859-1'</code> to <code>'win-1252'</code>. This means that while doing\nsomething like <code>http.get()</code>, if the returned charset is one of those listed in\nthe WHATWG specification it is possible that the server actually returned\n<code>'win-1252'</code>-encoded data, and using <code>'latin1'</code> encoding may incorrectly decode\nthe characters.</p>",
          "type": "module",
          "displayName": "Buffers and character encodings"
        },
        {
          "textRaw": "Buffers and TypedArrays",
          "name": "buffers_and_typedarrays",
          "meta": {
            "changes": [
              {
                "version": "v3.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2002",
                "description": "The `Buffer`s class now inherits from `Uint8Array`."
              }
            ]
          },
          "desc": "<p><code>Buffer</code> instances are also JavaScript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>\ninstances. All <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> methods are available on <code>Buffer</code>s. There are,\nhowever, subtle incompatibilities between the <code>Buffer</code> API and the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> API.</p>\n<p>In particular:</p>\n<ul>\n<li>While <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice\"><code>TypedArray.prototype.slice()</code></a> creates a copy of part of the <code>TypedArray</code>,\n<a href=\"#bufslicestart-end\"><code>Buffer.prototype.slice()</code></a> creates a view over the existing <code>Buffer</code>\nwithout copying. This behavior can be surprising, and only exists for legacy\ncompatibility. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray\"><code>TypedArray.prototype.subarray()</code></a> can be used to achieve\nthe behavior of <a href=\"#bufslicestart-end\"><code>Buffer.prototype.slice()</code></a> on both <code>Buffer</code>s\nand other <code>TypedArray</code>s and should be preferred.</li>\n<li><a href=\"#buftostringencoding-start-end\"><code>buf.toString()</code></a> is incompatible with its <code>TypedArray</code> equivalent.</li>\n<li>A number of methods, e.g. <a href=\"#bufindexofvalue-byteoffset-encoding\"><code>buf.indexOf()</code></a>, support additional arguments.</li>\n</ul>\n<p>There are two ways to create new <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instances from a <code>Buffer</code>:</p>\n<ul>\n<li>Passing a <code>Buffer</code> to a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> constructor will copy the <code>Buffer</code>s\ncontents, interpreted as an array of integers, and not as a byte sequence\nof the target type.</li>\n</ul>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\nconst uint32array = new Uint32Array(buf);\n\nconsole.log(uint32array);\n\n// Prints: Uint32Array(4) [ 1, 2, 3, 4 ]\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([1, 2, 3, 4]);\nconst uint32array = new Uint32Array(buf);\n\nconsole.log(uint32array);\n\n// Prints: Uint32Array(4) [ 1, 2, 3, 4 ]\n</code></pre>\n<ul>\n<li>Passing the <code>Buffer</code>s underlying <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> will create a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> that shares its memory with the <code>Buffer</code>.</li>\n</ul>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('hello', 'utf16le');\nconst uint16array = new Uint16Array(\n  buf.buffer,\n  buf.byteOffset,\n  buf.length / Uint16Array.BYTES_PER_ELEMENT);\n\nconsole.log(uint16array);\n\n// Prints: Uint16Array(5) [ 104, 101, 108, 108, 111 ]\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('hello', 'utf16le');\nconst uint16array = new Uint16Array(\n  buf.buffer,\n  buf.byteOffset,\n  buf.length / Uint16Array.BYTES_PER_ELEMENT);\n\nconsole.log(uint16array);\n\n// Prints: Uint16Array(5) [ 104, 101, 108, 108, 111 ]\n</code></pre>\n<p>It is possible to create a new <code>Buffer</code> that shares the same allocated\nmemory as a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance by using the <code>TypedArray</code> object's\n<code>.buffer</code> property in the same way. <a href=\"#static-method-bufferfromarraybuffer-byteoffset-length\"><code>Buffer.from()</code></a>\nbehaves like <code>new Uint8Array()</code> in this context.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Copies the contents of `arr`.\nconst buf1 = Buffer.from(arr);\n\n// Shares memory with `arr`.\nconst buf2 = Buffer.from(arr.buffer);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 88 a0>\nconsole.log(buf2);\n// Prints: &#x3C;Buffer 88 13 a0 0f>\n\narr[1] = 6000;\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 88 a0>\nconsole.log(buf2);\n// Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Copies the contents of `arr`.\nconst buf1 = Buffer.from(arr);\n\n// Shares memory with `arr`.\nconst buf2 = Buffer.from(arr.buffer);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 88 a0>\nconsole.log(buf2);\n// Prints: &#x3C;Buffer 88 13 a0 0f>\n\narr[1] = 6000;\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 88 a0>\nconsole.log(buf2);\n// Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>\n<p>When creating a <code>Buffer</code> using a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>'s <code>.buffer</code>, it is\npossible to use only a portion of the underlying <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> by passing in\n<code>byteOffset</code> and <code>length</code> parameters.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\nconsole.log(buf.length);\n// Prints: 16\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\nconsole.log(buf.length);\n// Prints: 16\n</code></pre>\n<p>The <code>Buffer.from()</code> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from\"><code>TypedArray.from()</code></a> have different signatures and\nimplementations. Specifically, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> variants accept a second\nargument that is a mapping function that is invoked on every element of the\ntyped array:</p>\n<ul>\n<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>\n</ul>\n<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping\nfunction:</p>\n<ul>\n<li><a href=\"#static-method-bufferfromarray\"><code>Buffer.from(array)</code></a></li>\n<li><a href=\"#static-method-bufferfrombuffer\"><code>Buffer.from(buffer)</code></a></li>\n<li><a href=\"#static-method-bufferfromarraybuffer-byteoffset-length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a></li>\n<li><a href=\"#static-method-bufferfromstring-encoding\"><code>Buffer.from(string[, encoding])</code></a></li>\n</ul>",
          "type": "module",
          "displayName": "Buffers and TypedArrays"
        },
        {
          "textRaw": "Buffers and iteration",
          "name": "buffers_and_iteration",
          "desc": "<p><code>Buffer</code> instances can be iterated over using <code>for..of</code> syntax:</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3]);\n\nfor (const b of buf) {\n  console.log(b);\n}\n// Prints:\n//   1\n//   2\n//   3\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([1, 2, 3]);\n\nfor (const b of buf) {\n  console.log(b);\n}\n// Prints:\n//   1\n//   2\n//   3\n</code></pre>\n<p>Additionally, the <a href=\"#bufvalues\"><code>buf.values()</code></a>, <a href=\"#bufkeys\"><code>buf.keys()</code></a>, and\n<a href=\"#bufentries\"><code>buf.entries()</code></a> methods can be used to create iterators.</p>",
          "type": "module",
          "displayName": "Buffers and iteration"
        },
        {
          "textRaw": "`node:buffer` module APIs",
          "name": "`node:buffer`_module_apis",
          "desc": "<p>While, the <code>Buffer</code> object is available as a global, there are additional\n<code>Buffer</code>-related APIs that are available only via the <code>node:buffer</code> module\naccessed using <code>require('node:buffer')</code>.</p>",
          "methods": [
            {
              "textRaw": "`buffer.atob(data)`",
              "type": "method",
              "name": "atob",
              "meta": {
                "added": [
                  "v15.13.0",
                  "v14.17.0"
                ],
                "changes": []
              },
              "stability": 3,
              "stabilityText": "Legacy. Use `Buffer.from(data, 'base64')` instead.",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`data` {any} The Base64-encoded input string.",
                      "name": "data",
                      "type": "any",
                      "desc": "The Base64-encoded input string."
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes a string of Base64-encoded data into bytes, and encodes those bytes\ninto a string using Latin-1 (ISO-8859-1).</p>\n<p>The <code>data</code> may be any JavaScript-value that can be coerced into a string.</p>\n<p><strong>This function is only provided for compatibility with legacy web platform APIs\nand should never be used in new code, because they use strings to represent\nbinary data and predate the introduction of typed arrays in JavaScript.\nFor code running using Node.js APIs, converting between base64-encoded strings\nand binary data should be performed using <code>Buffer.from(str, 'base64')</code> and\n<code>buf.toString('base64')</code>.</strong></p>"
            },
            {
              "textRaw": "`buffer.btoa(data)`",
              "type": "method",
              "name": "btoa",
              "meta": {
                "added": [
                  "v15.13.0",
                  "v14.17.0"
                ],
                "changes": []
              },
              "stability": 3,
              "stabilityText": "Legacy. Use `buf.toString('base64')` instead.",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`data` {any} An ASCII (Latin1) string.",
                      "name": "data",
                      "type": "any",
                      "desc": "An ASCII (Latin1) string."
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes\ninto a string using Base64.</p>\n<p>The <code>data</code> may be any JavaScript-value that can be coerced into a string.</p>\n<p><strong>This function is only provided for compatibility with legacy web platform APIs\nand should never be used in new code, because they use strings to represent\nbinary data and predate the introduction of typed arrays in JavaScript.\nFor code running using Node.js APIs, converting between base64-encoded strings\nand binary data should be performed using <code>Buffer.from(str, 'base64')</code> and\n<code>buf.toString('base64')</code>.</strong></p>"
            },
            {
              "textRaw": "`buffer.isAscii(input)`",
              "type": "method",
              "name": "isAscii",
              "meta": {
                "added": [
                  "v19.6.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "input {Buffer | ArrayBuffer | TypedArray} The input to validate.",
                      "name": "input",
                      "type": "Buffer | ArrayBuffer | TypedArray",
                      "desc": "The input to validate."
                    }
                  ]
                }
              ],
              "desc": "<p>This function returns <code>true</code> if <code>input</code> contains only valid ASCII-encoded data,\nincluding the case in which <code>input</code> is empty.</p>\n<p>Throws if the <code>input</code> is a detached array buffer.</p>"
            },
            {
              "textRaw": "`buffer.isUtf8(input)`",
              "type": "method",
              "name": "isUtf8",
              "meta": {
                "added": [
                  "v19.4.0",
                  "v18.14.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "input {Buffer | ArrayBuffer | TypedArray} The input to validate.",
                      "name": "input",
                      "type": "Buffer | ArrayBuffer | TypedArray",
                      "desc": "The input to validate."
                    }
                  ]
                }
              ],
              "desc": "<p>This function returns <code>true</code> if <code>input</code> contains only valid UTF-8-encoded data,\nincluding the case in which <code>input</code> is empty.</p>\n<p>Throws if the <code>input</code> is a detached array buffer.</p>"
            },
            {
              "textRaw": "`buffer.resolveObjectURL(id)`",
              "type": "method",
              "name": "resolveObjectURL",
              "meta": {
                "added": [
                  "v16.7.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": "Experimental",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Blob}",
                    "name": "return",
                    "type": "Blob"
                  },
                  "params": [
                    {
                      "textRaw": "`id` {string} A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.",
                      "name": "id",
                      "type": "string",
                      "desc": "A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`."
                    }
                  ]
                }
              ],
              "desc": "<p>Resolves a <code>'blob:nodedata:...'</code> an associated <a href=\"buffer.html#class-blob\" class=\"type\">&lt;Blob&gt;</a> object registered using\na prior call to <code>URL.createObjectURL()</code>.</p>"
            },
            {
              "textRaw": "`buffer.transcode(source, fromEnc, toEnc)`",
              "type": "method",
              "name": "transcode",
              "meta": {
                "added": [
                  "v7.1.0"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `source` parameter can now be a `Uint8Array`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`source` {Buffer|Uint8Array} A `Buffer` or `Uint8Array` instance.",
                      "name": "source",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or `Uint8Array` instance."
                    },
                    {
                      "textRaw": "`fromEnc` {string} The current encoding.",
                      "name": "fromEnc",
                      "type": "string",
                      "desc": "The current encoding."
                    },
                    {
                      "textRaw": "`toEnc` {string} To target encoding.",
                      "name": "toEnc",
                      "type": "string",
                      "desc": "To target encoding."
                    }
                  ]
                }
              ],
              "desc": "<p>Re-encodes the given <code>Buffer</code> or <code>Uint8Array</code> instance from one character\nencoding to another. Returns a new <code>Buffer</code> instance.</p>\n<p>Throws if the <code>fromEnc</code> or <code>toEnc</code> specify invalid character encodings or if\nconversion from <code>fromEnc</code> to <code>toEnc</code> is not permitted.</p>\n<p>Encodings supported by <code>buffer.transcode()</code> are: <code>'ascii'</code>, <code>'utf8'</code>,\n<code>'utf16le'</code>, <code>'ucs2'</code>, <code>'latin1'</code>, and <code>'binary'</code>.</p>\n<p>The transcoding process will use substitution characters if a given byte\nsequence cannot be adequately represented in the target encoding. For instance:</p>\n<pre><code class=\"language-mjs\">import { Buffer, transcode } from 'node:buffer';\n\nconst newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii');\nconsole.log(newBuf.toString('ascii'));\n// Prints: '?'\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer, transcode } = require('node:buffer');\n\nconst newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii');\nconsole.log(newBuf.toString('ascii'));\n// Prints: '?'\n</code></pre>\n<p>Because the Euro (<code>€</code>) sign is not representable in US-ASCII, it is replaced\nwith <code>?</code> in the transcoded <code>Buffer</code>.</p>"
            }
          ],
          "properties": [
            {
              "textRaw": "`INSPECT_MAX_BYTES` {integer} **Default:** `50`",
              "type": "integer",
              "name": "INSPECT_MAX_BYTES",
              "meta": {
                "added": [
                  "v0.5.4"
                ],
                "changes": []
              },
              "default": "`50`",
              "desc": "<p>Returns the maximum number of bytes that will be returned when\n<code>buf.inspect()</code> is called. This can be overridden by user modules. See\n<a href=\"util.html#utilinspectobject-options\"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>"
            },
            {
              "textRaw": "`kMaxLength` {integer} The largest size allowed for a single `Buffer` instance.",
              "type": "integer",
              "name": "kMaxLength",
              "meta": {
                "added": [
                  "v3.0.0"
                ],
                "changes": []
              },
              "desc": "<p>An alias for <a href=\"#bufferconstantsmax_length\"><code>buffer.constants.MAX_LENGTH</code></a>.</p>",
              "shortDesc": "The largest size allowed for a single `Buffer` instance."
            },
            {
              "textRaw": "`kStringMaxLength` {integer} The largest length allowed for a single `string` instance.",
              "type": "integer",
              "name": "kStringMaxLength",
              "meta": {
                "added": [
                  "v3.0.0"
                ],
                "changes": []
              },
              "desc": "<p>An alias for <a href=\"#bufferconstantsmax_string_length\"><code>buffer.constants.MAX_STRING_LENGTH</code></a>.</p>",
              "shortDesc": "The largest length allowed for a single `string` instance."
            }
          ],
          "classes": [
            {
              "textRaw": "Class: `SlowBuffer`",
              "type": "class",
              "name": "SlowBuffer",
              "meta": {
                "deprecated": [
                  "v6.0.0"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`Buffer.allocUnsafeSlow()`][] instead.",
              "desc": "<p>See <a href=\"#static-method-bufferallocunsafeslowsize\"><code>Buffer.allocUnsafeSlow()</code></a>. This was never a class in the sense that\nthe constructor always returned a <code>Buffer</code> instance, rather than a <code>SlowBuffer</code>\ninstance.</p>",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `SlowBuffer`.",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `SlowBuffer`."
                    }
                  ],
                  "desc": "<p>See <a href=\"#static-method-bufferallocunsafeslowsize\"><code>Buffer.allocUnsafeSlow()</code></a>.</p>"
                }
              ]
            }
          ],
          "modules": [
            {
              "textRaw": "Buffer constants",
              "name": "buffer_constants",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "properties": [
                {
                  "textRaw": "`MAX_LENGTH` {integer} The largest size allowed for a single `Buffer` instance.",
                  "type": "integer",
                  "name": "MAX_LENGTH",
                  "meta": {
                    "added": [
                      "v8.2.0"
                    ],
                    "changes": [
                      {
                        "version": "v15.0.0",
                        "pr-url": "https://github.com/nodejs/node/pull/35415",
                        "description": "Value is changed to 2<sup>32</sup> on 64-bit architectures."
                      },
                      {
                        "version": "v14.0.0",
                        "pr-url": "https://github.com/nodejs/node/pull/32116",
                        "description": "Value is changed from 2<sup>31</sup> - 1 to 2<sup>32</sup> - 1 on 64-bit architectures."
                      }
                    ]
                  },
                  "desc": "<p>On 32-bit architectures, this value currently is 2<sup>30</sup> - 1 (about 1\nGiB).</p>\n<p>On 64-bit architectures, this value currently is 2<sup>32</sup> (about 4 GiB).</p>\n<p>It reflects <a href=\"https://v8.github.io/api/head/classv8_1_1TypedArray.html#a54a48f4373da0850663c4393d843b9b0\"><code>v8::TypedArray::kMaxLength</code></a> under the hood.</p>\n<p>This value is also available as <a href=\"#bufferkmaxlength\"><code>buffer.kMaxLength</code></a>.</p>",
                  "shortDesc": "The largest size allowed for a single `Buffer` instance."
                },
                {
                  "textRaw": "`MAX_STRING_LENGTH` {integer} The largest length allowed for a single `string` instance.",
                  "type": "integer",
                  "name": "MAX_STRING_LENGTH",
                  "meta": {
                    "added": [
                      "v8.2.0"
                    ],
                    "changes": []
                  },
                  "desc": "<p>Represents the largest <code>length</code> that a <code>string</code> primitive can have, counted\nin UTF-16 code units.</p>\n<p>This value may depend on the JS engine that is being used.</p>",
                  "shortDesc": "The largest length allowed for a single `string` instance."
                }
              ],
              "type": "module",
              "displayName": "Buffer constants"
            }
          ],
          "type": "module",
          "displayName": "`node:buffer` module APIs"
        },
        {
          "textRaw": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`",
          "name": "`buffer.from()`,_`buffer.alloc()`,_and_`buffer.allocunsafe()`",
          "desc": "<p>In versions of Node.js prior to 6.0.0, <code>Buffer</code> instances were created using the\n<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>\ndifferently based on what arguments are provided:</p>\n<ul>\n<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>)\nallocates a new <code>Buffer</code> object of the specified size. Prior to Node.js 8.0.0,\nthe memory allocated for such <code>Buffer</code> instances is <em>not</em> initialized and\n<em>can contain sensitive data</em>. Such <code>Buffer</code> instances <em>must</em> be subsequently\ninitialized by using either <a href=\"#buffillvalue-offset-end-encoding\"><code>buf.fill(0)</code></a> or by writing to the\nentire <code>Buffer</code> before reading data from the <code>Buffer</code>.\nWhile this behavior is <em>intentional</em> to improve performance,\ndevelopment experience has demonstrated that a more explicit distinction is\nrequired between creating a fast-but-uninitialized <code>Buffer</code> versus creating a\nslower-but-safer <code>Buffer</code>. Since Node.js 8.0.0, <code>Buffer(num)</code> and <code>new Buffer(num)</code> return a <code>Buffer</code> with initialized memory.</li>\n<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the\npassed object's data into the <code>Buffer</code>.</li>\n<li>Passing an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a> returns a <code>Buffer</code>\nthat shares allocated memory with the given array buffer.</li>\n</ul>\n<p>Because the behavior of <code>new Buffer()</code> is different depending on the type of the\nfirst argument, security and reliability issues can be inadvertently introduced\ninto applications when argument validation or <code>Buffer</code> initialization is not\nperformed.</p>\n<p>For example, if an attacker can cause an application to receive a number where\na string is expected, the application may call <code>new Buffer(100)</code>\ninstead of <code>new Buffer(\"100\")</code>, leading it to allocate a 100 byte buffer instead\nof allocating a 3 byte buffer with content <code>\"100\"</code>. This is commonly possible\nusing JSON API calls. Since JSON distinguishes between numeric and string types,\nit allows injection of numbers where a naively written application that does not\nvalidate its input sufficiently might expect to always receive a string.\nBefore Node.js 8.0.0, the 100 byte buffer might contain\narbitrary pre-existing in-memory data, so may be used to expose in-memory\nsecrets to a remote attacker. Since Node.js 8.0.0, exposure of memory cannot\noccur because the data is zero-filled. However, other attacks are still\npossible, such as causing very large buffers to be allocated by the server,\nleading to performance degradation or crashing on memory exhaustion.</p>\n<p>To make the creation of <code>Buffer</code> instances more reliable and less error-prone,\nthe various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>\nand replaced by separate <code>Buffer.from()</code>, <a href=\"#static-method-bufferallocsize-fill-encoding\"><code>Buffer.alloc()</code></a>, and\n<a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> methods.</p>\n<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors\nto one of these new APIs.</em></p>\n<ul>\n<li><a href=\"#static-method-bufferfromarray\"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the\nprovided octets.</li>\n<li><a href=\"#static-method-bufferfromarraybuffer-byteoffset-length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>\nreturns a new <code>Buffer</code> that <em>shares the same allocated memory</em> as the given\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>.</li>\n<li><a href=\"#static-method-bufferfrombuffer\"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the\ncontents of the given <code>Buffer</code>.</li>\n<li><a href=\"#static-method-bufferfromstring-encoding\"><code>Buffer.from(string[, encoding])</code></a> returns a new\n<code>Buffer</code> that <em>contains a copy</em> of the provided string.</li>\n<li><a href=\"#static-method-bufferallocsize-fill-encoding\"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a new\ninitialized <code>Buffer</code> of the specified size. This method is slower than\n<a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe(size)</code></a> but guarantees that newly\ncreated <code>Buffer</code> instances never contain old data that is potentially\nsensitive. A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</li>\n<li><a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe(size)</code></a> and\n<a href=\"#static-method-bufferallocunsafeslowsize\"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a\nnew uninitialized <code>Buffer</code> of the specified <code>size</code>. Because the <code>Buffer</code> is\nuninitialized, the allocated segment of memory might contain old data that is\npotentially sensitive.</li>\n</ul>\n<p><code>Buffer</code> instances returned by <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> and\n<a href=\"#static-method-bufferfromarray\"><code>Buffer.from(array)</code></a> <em>may</em> be allocated off a shared internal memory pool\nif <code>size</code> is less than or equal to half <a href=\"#class-property-bufferpoolsize\"><code>Buffer.poolSize</code></a>. Instances\nreturned by <a href=\"#static-method-bufferallocunsafeslowsize\"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em> use the shared internal\nmemory pool.</p>",
          "modules": [
            {
              "textRaw": "The `--zero-fill-buffers` command-line option",
              "name": "the_`--zero-fill-buffers`_command-line_option",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "desc": "<p>Node.js can be started using the <code>--zero-fill-buffers</code> command-line option to\ncause all newly-allocated <code>Buffer</code> instances to be zero-filled upon creation by\ndefault. Without the option, buffers created with <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a>,\n<a href=\"#static-method-bufferallocunsafeslowsize\"><code>Buffer.allocUnsafeSlow()</code></a>, and <code>new SlowBuffer(size)</code> are not zero-filled.\nUse of this flag can have a measurable negative impact on performance. Use the\n<code>--zero-fill-buffers</code> option only when necessary to enforce that newly allocated\n<code>Buffer</code> instances cannot contain old data that is potentially sensitive.</p>\n<pre><code class=\"language-console\">$ node --zero-fill-buffers\n> Buffer.allocUnsafe(5);\n&#x3C;Buffer 00 00 00 00 00>\n</code></pre>",
              "type": "module",
              "displayName": "The `--zero-fill-buffers` command-line option"
            },
            {
              "textRaw": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?",
              "name": "what_makes_`buffer.allocunsafe()`_and_`buffer.allocunsafeslow()`_\"unsafe\"?",
              "desc": "<p>When calling <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> and <a href=\"#static-method-bufferallocunsafeslowsize\"><code>Buffer.allocUnsafeSlow()</code></a>, the\nsegment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While\nthis design makes the allocation of memory quite fast, the allocated segment of\nmemory might contain old data that is potentially sensitive. Using a <code>Buffer</code>\ncreated by <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the\nmemory can allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>\n<p>While there are clear performance advantages to using\n<a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a>, extra care <em>must</em> be taken in order to avoid\nintroducing security vulnerabilities into an application.</p>",
              "type": "module",
              "displayName": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?"
            }
          ],
          "type": "module",
          "displayName": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: `Blob`",
          "type": "class",
          "name": "Blob",
          "meta": {
            "added": [
              "v15.7.0",
              "v14.18.0"
            ],
            "changes": [
              {
                "version": [
                  "v18.0.0",
                  "v16.17.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/41270",
                "description": "No longer experimental."
              }
            ]
          },
          "desc": "<p>A <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\"><code>Blob</code></a> encapsulates immutable, raw data that can be safely shared across\nmultiple worker threads.</p>",
          "methods": [
            {
              "textRaw": "`blob.arrayBuffer()`",
              "type": "method",
              "name": "arrayBuffer",
              "meta": {
                "added": [
                  "v15.7.0",
                  "v14.18.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Promise}",
                    "name": "return",
                    "type": "Promise"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns a promise that fulfills with an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" class=\"type\">&lt;ArrayBuffer&gt;</a> containing a copy of\nthe <code>Blob</code> data.</p>"
            },
            {
              "textRaw": "`blob.slice([start[, end[, type]]])`",
              "type": "method",
              "name": "slice",
              "meta": {
                "added": [
                  "v15.7.0",
                  "v14.18.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`start` {number} The starting index.",
                      "name": "start",
                      "type": "number",
                      "desc": "The starting index."
                    },
                    {
                      "textRaw": "`end` {number} The ending index.",
                      "name": "end",
                      "type": "number",
                      "desc": "The ending index."
                    },
                    {
                      "textRaw": "`type` {string} The content-type for the new `Blob`",
                      "name": "type",
                      "type": "string",
                      "desc": "The content-type for the new `Blob`"
                    }
                  ]
                }
              ],
              "desc": "<p>Creates and returns a new <code>Blob</code> containing a subset of this <code>Blob</code> objects\ndata. The original <code>Blob</code> is not altered.</p>"
            },
            {
              "textRaw": "`blob.stream()`",
              "type": "method",
              "name": "stream",
              "meta": {
                "added": [
                  "v16.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {ReadableStream}",
                    "name": "return",
                    "type": "ReadableStream"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns a new <code>ReadableStream</code> that allows the content of the <code>Blob</code> to be read.</p>"
            },
            {
              "textRaw": "`blob.text()`",
              "type": "method",
              "name": "text",
              "meta": {
                "added": [
                  "v15.7.0",
                  "v14.18.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Promise}",
                    "name": "return",
                    "type": "Promise"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns a promise that fulfills with the contents of the <code>Blob</code> decoded as a\nUTF-8 string.</p>"
            }
          ],
          "properties": [
            {
              "textRaw": "`blob.size`",
              "name": "size",
              "meta": {
                "added": [
                  "v15.7.0",
                  "v14.18.0"
                ],
                "changes": []
              },
              "desc": "<p>The total size of the <code>Blob</code> in bytes.</p>"
            },
            {
              "textRaw": "`type` Type: {string}",
              "type": "string",
              "name": "Type",
              "meta": {
                "added": [
                  "v15.7.0",
                  "v14.18.0"
                ],
                "changes": []
              },
              "desc": "<p>The content-type of the <code>Blob</code>.</p>"
            }
          ],
          "modules": [
            {
              "textRaw": "`Blob` objects and `MessageChannel`",
              "name": "`blob`_objects_and_`messagechannel`",
              "desc": "<p>Once a <a href=\"buffer.html#class-blob\" class=\"type\">&lt;Blob&gt;</a> object is created, it can be sent via <code>MessagePort</code> to multiple\ndestinations without transferring or immediately copying the data. The data\ncontained by the <code>Blob</code> is copied only when the <code>arrayBuffer()</code> or <code>text()</code>\nmethods are called.</p>\n<pre><code class=\"language-mjs\">import { Blob, Buffer } from 'node:buffer';\nimport { setTimeout as delay } from 'node:timers/promises';\n\nconst blob = new Blob(['hello there']);\n\nconst mc1 = new MessageChannel();\nconst mc2 = new MessageChannel();\n\nmc1.port1.onmessage = async ({ data }) => {\n  console.log(await data.arrayBuffer());\n  mc1.port1.close();\n};\n\nmc2.port1.onmessage = async ({ data }) => {\n  await delay(1000);\n  console.log(await data.arrayBuffer());\n  mc2.port1.close();\n};\n\nmc1.port2.postMessage(blob);\nmc2.port2.postMessage(blob);\n\n// The Blob is still usable after posting.\nblob.text().then(console.log);\n</code></pre>\n<pre><code class=\"language-cjs\">const { Blob, Buffer } = require('node:buffer');\nconst { setTimeout: delay } = require('node:timers/promises');\n\nconst blob = new Blob(['hello there']);\n\nconst mc1 = new MessageChannel();\nconst mc2 = new MessageChannel();\n\nmc1.port1.onmessage = async ({ data }) => {\n  console.log(await data.arrayBuffer());\n  mc1.port1.close();\n};\n\nmc2.port1.onmessage = async ({ data }) => {\n  await delay(1000);\n  console.log(await data.arrayBuffer());\n  mc2.port1.close();\n};\n\nmc1.port2.postMessage(blob);\nmc2.port2.postMessage(blob);\n\n// The Blob is still usable after posting.\nblob.text().then(console.log);\n</code></pre>",
              "type": "module",
              "displayName": "`Blob` objects and `MessageChannel`"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`sources` {string\\[]|ArrayBuffer\\[]|TypedArray\\[]|DataView\\[]|Blob\\[]} An array of string, {ArrayBuffer}, {TypedArray}, {DataView}, or {Blob} objects, or any mix of such objects, that will be stored within the `Blob`.",
                  "name": "sources",
                  "type": "string\\[]|ArrayBuffer\\[]|TypedArray\\[]|DataView\\[]|Blob\\[]",
                  "desc": "An array of string, {ArrayBuffer}, {TypedArray}, {DataView}, or {Blob} objects, or any mix of such objects, that will be stored within the `Blob`."
                },
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`endings` {string} One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be converted to the platform native line-ending as specified by `require('node:os').EOL`.",
                      "name": "endings",
                      "type": "string",
                      "desc": "One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be converted to the platform native line-ending as specified by `require('node:os').EOL`."
                    },
                    {
                      "textRaw": "`type` {string} The Blob content-type. The intent is for `type` to convey the MIME media type of the data, however no validation of the type format is performed.",
                      "name": "type",
                      "type": "string",
                      "desc": "The Blob content-type. The intent is for `type` to convey the MIME media type of the data, however no validation of the type format is performed."
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>Blob</code> object containing a concatenation of the given sources.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" class=\"type\">&lt;ArrayBuffer&gt;</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\" class=\"type\">&lt;TypedArray&gt;</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\" class=\"type\">&lt;DataView&gt;</a>, and <a href=\"buffer.html#class-buffer\" class=\"type\">&lt;Buffer&gt;</a> sources are copied into\nthe 'Blob' and can therefore be safely modified after the 'Blob' is created.</p>\n<p>String sources are encoded as UTF-8 byte sequences and copied into the Blob.\nUnmatched surrogate pairs within each string part will be replaced by Unicode\nU+FFFD replacement characters.</p>"
            }
          ]
        },
        {
          "textRaw": "Class: `Buffer`",
          "type": "class",
          "name": "Buffer",
          "desc": "<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.</p>",
          "classMethods": [
            {
              "textRaw": "Static method: `Buffer.alloc(size[, fill[, encoding]])`",
              "type": "classMethod",
              "name": "alloc",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": [
                  {
                    "version": "v15.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/34682",
                    "description": "Throw ERR_INVALID_ARG_VALUE instead of ERR_INVALID_OPT_VALUE for invalid input arguments."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18129",
                    "description": "Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/17427",
                    "description": "Specifying an invalid string for `fill` triggers a thrown exception."
                  },
                  {
                    "version": "v8.9.3",
                    "pr-url": "https://github.com/nodejs/node/pull/17428",
                    "description": "Specifying an invalid string for `fill` now results in a zero-filled buffer."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    },
                    {
                      "textRaw": "`fill` {string|Buffer|Uint8Array|integer} A value to pre-fill the new `Buffer` with. **Default:** `0`.",
                      "name": "fill",
                      "type": "string|Buffer|Uint8Array|integer",
                      "default": "`0`",
                      "desc": "A value to pre-fill the new `Buffer` with."
                    },
                    {
                      "textRaw": "`encoding` {string} If `fill` is a string, this is its encoding. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `fill` is a string, this is its encoding."
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the\n<code>Buffer</code> will be zero-filled.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(5);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.alloc(5);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00>\n</code></pre>\n<p>If <code>size</code> is larger than\n<a href=\"#bufferconstantsmax_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#err_invalid_arg_value\"><code>ERR_INVALID_ARG_VALUE</code></a>\nis thrown.</p>\n<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling\n<a href=\"#buffillvalue-offset-end-encoding\"><code>buf.fill(fill)</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(5, 'a');\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 61 61 61 61 61>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.alloc(5, 'a');\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 61 61 61 61 61>\n</code></pre>\n<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be\ninitialized by calling <a href=\"#buffillvalue-offset-end-encoding\"><code>buf.fill(fill, encoding)</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n</code></pre>\n<p>Calling <a href=\"#static-method-bufferallocsize-fill-encoding\"><code>Buffer.alloc()</code></a> can be measurably slower than the alternative\n<a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> but ensures that the newly created <code>Buffer</code> instance\ncontents will never contain sensitive data from previous allocations, including\ndata that might not have been allocated for <code>Buffer</code>s.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.allocUnsafe(size)`",
              "type": "classMethod",
              "name": "allocUnsafe",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": [
                  {
                    "version": "v15.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/34682",
                    "description": "Throw ERR_INVALID_ARG_VALUE instead of ERR_INVALID_OPT_VALUE for invalid input arguments."
                  },
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/7079",
                    "description": "Passing a negative `size` will now throw an error."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#bufferconstantsmax_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#err_invalid_arg_value\"><code>ERR_INVALID_ARG_VALUE</code></a>\nis thrown.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#static-method-bufferallocsize-fill-encoding\"><code>Buffer.alloc()</code></a> instead to initialize\n<code>Buffer</code> instances with zeroes.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(10);\n\nconsole.log(buf);\n// Prints (contents may vary): &#x3C;Buffer a0 8b 28 3f 01 00 00 00 50 32>\n\nbuf.fill(0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00 00 00 00 00 00>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(10);\n\nconsole.log(buf);\n// Prints (contents may vary): &#x3C;Buffer a0 8b 28 3f 01 00 00 00 50 32>\n\nbuf.fill(0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00 00 00 00 00 00>\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<p>The <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of\nsize <a href=\"#class-property-bufferpoolsize\"><code>Buffer.poolSize</code></a> that is used as a pool for the fast allocation of new\n<code>Buffer</code> instances created using <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a>,\n<a href=\"#static-method-bufferfromarray\"><code>Buffer.from(array)</code></a>, <a href=\"#static-method-bufferconcatlist-totallength\"><code>Buffer.concat()</code></a>, and the deprecated\n<code>new Buffer(size)</code> constructor only when <code>size</code> is less than or equal\nto <code>Buffer.poolSize >> 1</code> (floor of <a href=\"#class-property-bufferpoolsize\"><code>Buffer.poolSize</code></a> divided by two).</p>\n<p>Use of this pre-allocated internal memory pool is a key difference between\ncalling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.\nSpecifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal <code>Buffer</code>\npool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal\n<code>Buffer</code> pool if <code>size</code> is less than or equal to half <a href=\"#class-property-bufferpoolsize\"><code>Buffer.poolSize</code></a>. The\ndifference is subtle but can be important when an application requires the\nadditional performance that <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> provides.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.allocUnsafeSlow(size)`",
              "type": "classMethod",
              "name": "allocUnsafeSlow",
              "meta": {
                "added": [
                  "v5.12.0"
                ],
                "changes": [
                  {
                    "version": "v15.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/34682",
                    "description": "Throw ERR_INVALID_ARG_VALUE instead of ERR_INVALID_OPT_VALUE for invalid input arguments."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#bufferconstantsmax_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#err_invalid_arg_value\"><code>ERR_INVALID_ARG_VALUE</code></a>\nis thrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#buffillvalue-offset-end-encoding\"><code>buf.fill(0)</code></a> to initialize\nsuch <code>Buffer</code> instances with zeroes.</p>\n<p>When using <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> to allocate new <code>Buffer</code> instances,\nallocations under 4 KiB are sliced from a single pre-allocated <code>Buffer</code>. This\nallows applications to avoid the garbage collection overhead of creating many\nindividually allocated <code>Buffer</code> instances. This approach improves both\nperformance and memory usage by eliminating the need to track and clean up as\nmany individual <code>ArrayBuffer</code> objects.</p>\n<p>However, in the case where a developer may need to retain a small chunk of\nmemory from a pool for an indeterminate amount of time, it may be appropriate\nto create an un-pooled <code>Buffer</code> instance using <code>Buffer.allocUnsafeSlow()</code> and\nthen copying out the relevant bits.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Need to keep around a few small chunks of memory.\nconst store = [];\n\nsocket.on('readable', () => {\n  let data;\n  while (null !== (data = readable.read())) {\n    // Allocate for retained data.\n    const sb = Buffer.allocUnsafeSlow(10);\n\n    // Copy the data into the new allocation.\n    data.copy(sb, 0, 0, 10);\n\n    store.push(sb);\n  }\n});\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Need to keep around a few small chunks of memory.\nconst store = [];\n\nsocket.on('readable', () => {\n  let data;\n  while (null !== (data = readable.read())) {\n    // Allocate for retained data.\n    const sb = Buffer.allocUnsafeSlow(10);\n\n    // Copy the data into the new allocation.\n    data.copy(sb, 0, 0, 10);\n\n    store.push(sb);\n  }\n});\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.byteLength(string[, encoding])`",
              "type": "classMethod",
              "name": "byteLength",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": [
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/8946",
                    "description": "Passing invalid input will now throw an error."
                  },
                  {
                    "version": "v5.10.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5255",
                    "description": "The `string` parameter can now be any `TypedArray`, `DataView` or `ArrayBuffer`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The number of bytes contained within `string`.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The number of bytes contained within `string`."
                  },
                  "params": [
                    {
                      "textRaw": "`string` {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} A value to calculate the length of.",
                      "name": "string",
                      "type": "string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer",
                      "desc": "A value to calculate the length of."
                    },
                    {
                      "textRaw": "`encoding` {string} If `string` is a string, this is its encoding. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `string` is a string, this is its encoding."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns the byte length of a string when encoded using <code>encoding</code>.\nThis is not the same as <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\"><code>String.prototype.length</code></a>, which does not account\nfor the encoding that is used to convert the string into bytes.</p>\n<p>For <code>'base64'</code>, <code>'base64url'</code>, and <code>'hex'</code>, this function assumes valid input.\nFor strings that contain non-base64/hex-encoded data (e.g. whitespace), the\nreturn value might be greater than the length of a <code>Buffer</code> created from the\nstring.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst str = '\\u00bd + \\u00bc = \\u00be';\n\nconsole.log(`${str}: ${str.length} characters, ` +\n            `${Buffer.byteLength(str, 'utf8')} bytes`);\n// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst str = '\\u00bd + \\u00bc = \\u00be';\n\nconsole.log(`${str}: ${str.length} characters, ` +\n            `${Buffer.byteLength(str, 'utf8')} bytes`);\n// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes\n</code></pre>\n<p>When <code>string</code> is a <code>Buffer</code>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\"><code>DataView</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>/\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a>, the byte length as reported by <code>.byteLength</code>\nis returned.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.compare(buf1, buf2)`",
              "type": "classMethod",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The arguments can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} Either `-1`, `0`, or `1`, depending on the result of the comparison. See [`buf.compare()`][] for details.",
                    "name": "return",
                    "type": "integer",
                    "desc": "Either `-1`, `0`, or `1`, depending on the result of the comparison. See [`buf.compare()`][] for details."
                  },
                  "params": [
                    {
                      "textRaw": "`buf1` {Buffer|Uint8Array}",
                      "name": "buf1",
                      "type": "Buffer|Uint8Array"
                    },
                    {
                      "textRaw": "`buf2` {Buffer|Uint8Array}",
                      "name": "buf2",
                      "type": "Buffer|Uint8Array"
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf1</code> to <code>buf2</code>, typically for the purpose of sorting arrays of\n<code>Buffer</code> instances. This is equivalent to calling\n<a href=\"#bufcomparetarget-targetstart-targetend-sourcestart-sourceend\"><code>buf1.compare(buf2)</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('1234');\nconst buf2 = Buffer.from('0123');\nconst arr = [buf1, buf2];\n\nconsole.log(arr.sort(Buffer.compare));\n// Prints: [ &#x3C;Buffer 30 31 32 33>, &#x3C;Buffer 31 32 33 34> ]\n// (This result is equal to: [buf2, buf1].)\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from('1234');\nconst buf2 = Buffer.from('0123');\nconst arr = [buf1, buf2];\n\nconsole.log(arr.sort(Buffer.compare));\n// Prints: [ &#x3C;Buffer 30 31 32 33>, &#x3C;Buffer 31 32 33 34> ]\n// (This result is equal to: [buf2, buf1].)\n</code></pre>"
            },
            {
              "textRaw": "Static method: `Buffer.concat(list[, totalLength])`",
              "type": "classMethod",
              "name": "concat",
              "meta": {
                "added": [
                  "v0.7.11"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The elements of `list` can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`list` {Buffer\\[] | Uint8Array\\[]} List of `Buffer` or [`Uint8Array`][] instances to concatenate.",
                      "name": "list",
                      "type": "Buffer\\[] | Uint8Array\\[]",
                      "desc": "List of `Buffer` or [`Uint8Array`][] instances to concatenate."
                    },
                    {
                      "textRaw": "`totalLength` {integer} Total length of the `Buffer` instances in `list` when concatenated.",
                      "name": "totalLength",
                      "type": "integer",
                      "desc": "Total length of the `Buffer` instances in `list` when concatenated."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>\ninstances in the <code>list</code> together.</p>\n<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length\n<code>Buffer</code> is returned.</p>\n<p>If <code>totalLength</code> is not provided, it is calculated from the <code>Buffer</code> instances\nin <code>list</code> by adding their lengths.</p>\n<p>If <code>totalLength</code> is provided, it is coerced to an unsigned integer. If the\ncombined length of the <code>Buffer</code>s in <code>list</code> exceeds <code>totalLength</code>, the result is\ntruncated to <code>totalLength</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Create a single `Buffer` from a list of three `Buffer` instances.\n\nconst buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\nconsole.log(totalLength);\n// Prints: 42\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n\nconsole.log(bufA);\n// Prints: &#x3C;Buffer 00 00 00 00 ...>\nconsole.log(bufA.length);\n// Prints: 42\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Create a single `Buffer` from a list of three `Buffer` instances.\n\nconst buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\nconsole.log(totalLength);\n// Prints: 42\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n\nconsole.log(bufA);\n// Prints: &#x3C;Buffer 00 00 00 00 ...>\nconsole.log(bufA.length);\n// Prints: 42\n</code></pre>\n<p><code>Buffer.concat()</code> may also use the internal <code>Buffer</code> pool like\n<a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> does.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.from(array)`",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`array` {integer\\[]}",
                      "name": "array",
                      "type": "integer\\[]"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of bytes in the range <code>0</code> – <code>255</code>.\nArray entries outside that range will be truncated to fit into it.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code> or another type\nappropriate for <code>Buffer.from()</code> variants.</p>\n<p><code>Buffer.from(array)</code> and <a href=\"#static-method-bufferfromstring-encoding\"><code>Buffer.from(string)</code></a> may also use the internal\n<code>Buffer</code> pool like <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a> does.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.from(arrayBuffer[, byteOffset[, length]])`",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`arrayBuffer` {ArrayBuffer|SharedArrayBuffer} An [`ArrayBuffer`][], [`SharedArrayBuffer`][], for example the `.buffer` property of a [`TypedArray`][].",
                      "name": "arrayBuffer",
                      "type": "ArrayBuffer|SharedArrayBuffer",
                      "desc": "An [`ArrayBuffer`][], [`SharedArrayBuffer`][], for example the `.buffer` property of a [`TypedArray`][]."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Index of first byte to expose. **Default:** `0`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Index of first byte to expose."
                    },
                    {
                      "textRaw": "`length` {integer} Number of bytes to expose. **Default:** `arrayBuffer.byteLength - byteOffset`.",
                      "name": "length",
                      "type": "integer",
                      "default": "`arrayBuffer.byteLength - byteOffset`",
                      "desc": "Number of bytes to expose."
                    }
                  ]
                }
              ],
              "desc": "<p>This creates a view of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> without copying the underlying\nmemory. For example, when passed a reference to the <code>.buffer</code> property of a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will share the same\nallocated memory as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>'s underlying <code>ArrayBuffer</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`.\nconst buf = Buffer.from(arr.buffer);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 a0 0f>\n\n// Changing the original Uint16Array changes the Buffer also.\narr[1] = 6000;\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`.\nconst buf = Buffer.from(arr.buffer);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 a0 0f>\n\n// Changing the original Uint16Array changes the Buffer also.\narr[1] = 6000;\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\n\nconsole.log(buf.length);\n// Prints: 2\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\n\nconsole.log(buf.length);\n// Prints: 2\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a> or another type appropriate for <code>Buffer.from()</code>\nvariants.</p>\n<p>It is important to remember that a backing <code>ArrayBuffer</code> can cover a range\nof memory that extends beyond the bounds of a <code>TypedArray</code> view. A new\n<code>Buffer</code> created using the <code>buffer</code> property of a <code>TypedArray</code> may extend\nbeyond the range of the <code>TypedArray</code>:</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4 elements\nconst arrB = new Uint8Array(arrA.buffer, 1, 2); // 2 elements\nconsole.log(arrA.buffer === arrB.buffer); // true\n\nconst buf = Buffer.from(arrB.buffer);\nconsole.log(buf);\n// Prints: &#x3C;Buffer 63 64 65 66>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4 elements\nconst arrB = new Uint8Array(arrA.buffer, 1, 2); // 2 elements\nconsole.log(arrA.buffer === arrB.buffer); // true\n\nconst buf = Buffer.from(arrB.buffer);\nconsole.log(buf);\n// Prints: &#x3C;Buffer 63 64 65 66>\n</code></pre>"
            },
            {
              "textRaw": "Static method: `Buffer.from(buffer)`",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buffer` {Buffer|Uint8Array} An existing `Buffer` or [`Uint8Array`][] from which to copy data.",
                      "name": "buffer",
                      "type": "Buffer|Uint8Array",
                      "desc": "An existing `Buffer` or [`Uint8Array`][] from which to copy data."
                    }
                  ]
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('buffer');\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// Prints: auffer\nconsole.log(buf2.toString());\n// Prints: buffer\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from('buffer');\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// Prints: auffer\nconsole.log(buf2.toString());\n// Prints: buffer\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code> or another type\nappropriate for <code>Buffer.from()</code> variants.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.from(object[, offsetOrEncoding[, length]])`",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`object` {Object} An object supporting `Symbol.toPrimitive` or `valueOf()`.",
                      "name": "object",
                      "type": "Object",
                      "desc": "An object supporting `Symbol.toPrimitive` or `valueOf()`."
                    },
                    {
                      "textRaw": "`offsetOrEncoding` {integer|string} A byte-offset or encoding.",
                      "name": "offsetOrEncoding",
                      "type": "integer|string",
                      "desc": "A byte-offset or encoding."
                    },
                    {
                      "textRaw": "`length` {integer} A length.",
                      "name": "length",
                      "type": "integer",
                      "desc": "A length."
                    }
                  ]
                }
              ],
              "desc": "<p>For objects whose <code>valueOf()</code> function returns a value not strictly equal to\n<code>object</code>, returns <code>Buffer.from(object.valueOf(), offsetOrEncoding, length)</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from(new String('this is a test'));\n// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from(new String('this is a test'));\n// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n</code></pre>\n<p>For objects that support <code>Symbol.toPrimitive</code>, returns\n<code>Buffer.from(object[Symbol.toPrimitive]('string'), offsetOrEncoding)</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nclass Foo {\n  [Symbol.toPrimitive]() {\n    return 'this is a test';\n  }\n}\n\nconst buf = Buffer.from(new Foo(), 'utf8');\n// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nclass Foo {\n  [Symbol.toPrimitive]() {\n    return 'this is a test';\n  }\n}\n\nconst buf = Buffer.from(new Foo(), 'utf8');\n// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>object</code> does not have the mentioned methods or\nis not of another type appropriate for <code>Buffer.from()</code> variants.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.from(string[, encoding])`",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` {string} A string to encode.",
                      "name": "string",
                      "type": "string",
                      "desc": "A string to encode."
                    },
                    {
                      "textRaw": "`encoding` {string} The encoding of `string`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The encoding of `string`."
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies\nthe character encoding to be used when converting <code>string</code> into bytes.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('this is a tést');\nconst buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\n\nconsole.log(buf1.toString());\n// Prints: this is a tést\nconsole.log(buf2.toString());\n// Prints: this is a tést\nconsole.log(buf1.toString('latin1'));\n// Prints: this is a tÃ©st\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from('this is a tést');\nconst buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\n\nconsole.log(buf1.toString());\n// Prints: this is a tést\nconsole.log(buf2.toString());\n// Prints: this is a tést\nconsole.log(buf1.toString('latin1'));\n// Prints: this is a tÃ©st\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>string</code> is not a string or another type\nappropriate for <code>Buffer.from()</code> variants.</p>"
            },
            {
              "textRaw": "Static method: `Buffer.isBuffer(obj)`",
              "type": "classMethod",
              "name": "isBuffer",
              "meta": {
                "added": [
                  "v0.1.101"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` {Object}",
                      "name": "obj",
                      "type": "Object"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nBuffer.isBuffer(Buffer.alloc(10)); // true\nBuffer.isBuffer(Buffer.from('foo')); // true\nBuffer.isBuffer('a string'); // false\nBuffer.isBuffer([]); // false\nBuffer.isBuffer(new Uint8Array(1024)); // false\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nBuffer.isBuffer(Buffer.alloc(10)); // true\nBuffer.isBuffer(Buffer.from('foo')); // true\nBuffer.isBuffer('a string'); // false\nBuffer.isBuffer([]); // false\nBuffer.isBuffer(new Uint8Array(1024)); // false\n</code></pre>"
            },
            {
              "textRaw": "Static method: `Buffer.isEncoding(encoding)`",
              "type": "classMethod",
              "name": "isEncoding",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {string} A character encoding name to check.",
                      "name": "encoding",
                      "type": "string",
                      "desc": "A character encoding name to check."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>encoding</code> is the name of a supported character encoding,\nor <code>false</code> otherwise.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconsole.log(Buffer.isEncoding('utf8'));\n// Prints: true\n\nconsole.log(Buffer.isEncoding('hex'));\n// Prints: true\n\nconsole.log(Buffer.isEncoding('utf/8'));\n// Prints: false\n\nconsole.log(Buffer.isEncoding(''));\n// Prints: false\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconsole.log(Buffer.isEncoding('utf8'));\n// Prints: true\n\nconsole.log(Buffer.isEncoding('hex'));\n// Prints: true\n\nconsole.log(Buffer.isEncoding('utf/8'));\n// Prints: false\n\nconsole.log(Buffer.isEncoding(''));\n// Prints: false\n</code></pre>"
            }
          ],
          "properties": [
            {
              "textRaw": "`poolSize` {integer} **Default:** `8192`",
              "type": "integer",
              "name": "poolSize",
              "meta": {
                "added": [
                  "v0.11.3"
                ],
                "changes": []
              },
              "default": "`8192`",
              "desc": "<p>This is the size (in bytes) of pre-allocated internal <code>Buffer</code> instances used\nfor pooling. This value may be modified.</p>"
            },
            {
              "textRaw": "`[index]` `index` {integer}",
              "type": "integer",
              "name": "index",
              "desc": "<p>The index operator <code>[index]</code> can be used to get and set the octet at position\n<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value\nrange is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>\n<p>This operator is inherited from <code>Uint8Array</code>, so its behavior on out-of-bounds\naccess is the same as <code>Uint8Array</code>. In other words, <code>buf[index]</code> returns\n<code>undefined</code> when <code>index</code> is negative or greater or equal to <code>buf.length</code>, and\n<code>buf[index] = value</code> does not modify the buffer if <code>index</code> is negative or\n<code>>= buf.length</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Copy an ASCII string into a `Buffer` one byte at a time.\n// (This only works for ASCII-only strings. In general, one should use\n// `Buffer.from()` to perform this conversion.)\n\nconst str = 'Node.js';\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i &#x3C; str.length; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf.toString('utf8'));\n// Prints: Node.js\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Copy an ASCII string into a `Buffer` one byte at a time.\n// (This only works for ASCII-only strings. In general, one should use\n// `Buffer.from()` to perform this conversion.)\n\nconst str = 'Node.js';\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i &#x3C; str.length; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf.toString('utf8'));\n// Prints: Node.js\n</code></pre>"
            },
            {
              "textRaw": "`buffer` {ArrayBuffer} The underlying `ArrayBuffer` object based on which this `Buffer` object is created.",
              "type": "ArrayBuffer",
              "name": "buffer",
              "desc": "<p>This <code>ArrayBuffer</code> is not guaranteed to correspond exactly to the original\n<code>Buffer</code>. See the notes on <code>buf.byteOffset</code> for details.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst arrayBuffer = new ArrayBuffer(16);\nconst buffer = Buffer.from(arrayBuffer);\n\nconsole.log(buffer.buffer === arrayBuffer);\n// Prints: true\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst arrayBuffer = new ArrayBuffer(16);\nconst buffer = Buffer.from(arrayBuffer);\n\nconsole.log(buffer.buffer === arrayBuffer);\n// Prints: true\n</code></pre>",
              "shortDesc": "The underlying `ArrayBuffer` object based on which this `Buffer` object is created."
            },
            {
              "textRaw": "`byteOffset` {integer} The `byteOffset` of the `Buffer`s underlying `ArrayBuffer` object.",
              "type": "integer",
              "name": "byteOffset",
              "desc": "<p>When setting <code>byteOffset</code> in <code>Buffer.from(ArrayBuffer, byteOffset, length)</code>,\nor sometimes when allocating a <code>Buffer</code> smaller than <code>Buffer.poolSize</code>, the\nbuffer does not start from a zero offset on the underlying <code>ArrayBuffer</code>.</p>\n<p>This can cause problems when accessing the underlying <code>ArrayBuffer</code> directly\nusing <code>buf.buffer</code>, as other parts of the <code>ArrayBuffer</code> may be unrelated\nto the <code>Buffer</code> object itself.</p>\n<p>A common issue when creating a <code>TypedArray</code> object that shares its memory with\na <code>Buffer</code> is that in this case one needs to specify the <code>byteOffset</code> correctly:</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Create a buffer smaller than `Buffer.poolSize`.\nconst nodeBuffer = Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n// When casting the Node.js Buffer to an Int8Array, use the byteOffset\n// to refer only to the part of `nodeBuffer.buffer` that contains the memory\n// for `nodeBuffer`.\nnew Int8Array(nodeBuffer.buffer, nodeBuffer.byteOffset, nodeBuffer.length);\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Create a buffer smaller than `Buffer.poolSize`.\nconst nodeBuffer = Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n// When casting the Node.js Buffer to an Int8Array, use the byteOffset\n// to refer only to the part of `nodeBuffer.buffer` that contains the memory\n// for `nodeBuffer`.\nnew Int8Array(nodeBuffer.buffer, nodeBuffer.byteOffset, nodeBuffer.length);\n</code></pre>",
              "shortDesc": "The `byteOffset` of the `Buffer`s underlying `ArrayBuffer` object."
            },
            {
              "textRaw": "`length` {integer}",
              "type": "integer",
              "name": "length",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Returns the number of bytes in <code>buf</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Create a `Buffer` and write a shorter string to it using UTF-8.\n\nconst buf = Buffer.alloc(1234);\n\nconsole.log(buf.length);\n// Prints: 1234\n\nbuf.write('some string', 0, 'utf8');\n\nconsole.log(buf.length);\n// Prints: 1234\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Create a `Buffer` and write a shorter string to it using UTF-8.\n\nconst buf = Buffer.alloc(1234);\n\nconsole.log(buf.length);\n// Prints: 1234\n\nbuf.write('some string', 0, 'utf8');\n\nconsole.log(buf.length);\n// Prints: 1234\n</code></pre>"
            },
            {
              "textRaw": "`buf.parent`",
              "name": "parent",
              "meta": {
                "deprecated": [
                  "v8.0.0"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`buf.buffer`][] instead.",
              "desc": "<p>The <code>buf.parent</code> property is a deprecated alias for <code>buf.buffer</code>.</p>"
            }
          ],
          "methods": [
            {
              "textRaw": "`buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])`",
              "type": "method",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `target` parameter can now be a `Uint8Array`."
                  },
                  {
                    "version": "v5.11.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5880",
                    "description": "Additional parameters for specifying offsets are supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer|Uint8Array} A `Buffer` or [`Uint8Array`][] with which to compare `buf`.",
                      "name": "target",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or [`Uint8Array`][] with which to compare `buf`."
                    },
                    {
                      "textRaw": "`targetStart` {integer} The offset within `target` at which to begin comparison. **Default:** `0`.",
                      "name": "targetStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `target` at which to begin comparison."
                    },
                    {
                      "textRaw": "`targetEnd` {integer} The offset within `target` at which to end comparison (not inclusive). **Default:** `target.length`.",
                      "name": "targetEnd",
                      "type": "integer",
                      "default": "`target.length`",
                      "desc": "The offset within `target` at which to end comparison (not inclusive)."
                    },
                    {
                      "textRaw": "`sourceStart` {integer} The offset within `buf` at which to begin comparison. **Default:** `0`.",
                      "name": "sourceStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `buf` at which to begin comparison."
                    },
                    {
                      "textRaw": "`sourceEnd` {integer} The offset within `buf` at which to end comparison (not inclusive). **Default:** [`buf.length`][].",
                      "name": "sourceEnd",
                      "type": "integer",
                      "default": "[`buf.length`][]",
                      "desc": "The offset within `buf` at which to end comparison (not inclusive)."
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>\ncomes before, after, or is the same as <code>target</code> in sort order.\nComparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>\n<ul>\n<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>\n<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>\n<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>\n</ul>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ &#x3C;Buffer 41 42 43>, &#x3C;Buffer 41 42 43 44>, &#x3C;Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2].)\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ &#x3C;Buffer 41 42 43>, &#x3C;Buffer 41 42 43 44>, &#x3C;Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2].)\n</code></pre>\n<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>\narguments can be used to limit the comparison to specific ranges within <code>target</code>\nand <code>buf</code> respectively.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n</code></pre>\n<p><a href=\"errors.html#err_out_of_range\"><code>ERR_OUT_OF_RANGE</code></a> is thrown if <code>targetStart &#x3C; 0</code>, <code>sourceStart &#x3C; 0</code>,\n<code>targetEnd > target.byteLength</code>, or <code>sourceEnd > source.byteLength</code>.</p>"
            },
            {
              "textRaw": "`buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])`",
              "type": "method",
              "name": "copy",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The number of bytes copied.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The number of bytes copied."
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer|Uint8Array} A `Buffer` or [`Uint8Array`][] to copy into.",
                      "name": "target",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or [`Uint8Array`][] to copy into."
                    },
                    {
                      "textRaw": "`targetStart` {integer} The offset within `target` at which to begin writing. **Default:** `0`.",
                      "name": "targetStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `target` at which to begin writing."
                    },
                    {
                      "textRaw": "`sourceStart` {integer} The offset within `buf` from which to begin copying. **Default:** `0`.",
                      "name": "sourceStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `buf` from which to begin copying."
                    },
                    {
                      "textRaw": "`sourceEnd` {integer} The offset within `buf` at which to stop copying (not inclusive). **Default:** [`buf.length`][].",
                      "name": "sourceEnd",
                      "type": "integer",
                      "default": "[`buf.length`][]",
                      "desc": "The offset within `buf` at which to stop copying (not inclusive)."
                    }
                  ]
                }
              ],
              "desc": "<p>Copies data from a region of <code>buf</code> to a region in <code>target</code>, even if the <code>target</code>\nmemory region overlaps with <code>buf</code>.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set\"><code>TypedArray.prototype.set()</code></a> performs the same operation, and is available\nfor all TypedArrays, including Node.js <code>Buffer</code>s, although it takes\ndifferent function arguments.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\nbuf1.copy(buf2, 8, 16, 20);\n// This is equivalent to:\n// buf2.set(buf1.subarray(16, 20), 8);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\nbuf1.copy(buf2, 8, 16, 20);\n// This is equivalent to:\n// buf2.set(buf1.subarray(16, 20), 8);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n</code></pre>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n</code></pre>"
            },
            {
              "textRaw": "`buf.entries()`",
              "type": "method",
              "name": "entries",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator}",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>[index, byte]</code> pairs from the contents\nof <code>buf</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Log the entire contents of a `Buffer`.\n\nconst buf = Buffer.from('buffer');\n\nfor (const pair of buf.entries()) {\n  console.log(pair);\n}\n// Prints:\n//   [0, 98]\n//   [1, 117]\n//   [2, 102]\n//   [3, 102]\n//   [4, 101]\n//   [5, 114]\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Log the entire contents of a `Buffer`.\n\nconst buf = Buffer.from('buffer');\n\nfor (const pair of buf.entries()) {\n  console.log(pair);\n}\n// Prints:\n//   [0, 98]\n//   [1, 117]\n//   [2, 102]\n//   [3, 102]\n//   [4, 101]\n//   [5, 114]\n</code></pre>"
            },
            {
              "textRaw": "`buf.equals(otherBuffer)`",
              "type": "method",
              "name": "equals",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The arguments can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer|Uint8Array} A `Buffer` or [`Uint8Array`][] with which to compare `buf`.",
                      "name": "otherBuffer",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or [`Uint8Array`][] with which to compare `buf`."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,\n<code>false</code> otherwise. Equivalent to\n<a href=\"#bufcomparetarget-targetstart-targetend-sourcestart-sourceend\"><code>buf.compare(otherBuffer) === 0</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n</code></pre>"
            },
            {
              "textRaw": "`buf.fill(value[, offset[, end]][, encoding])`",
              "type": "method",
              "name": "fill",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v11.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/22969",
                    "description": "Throws `ERR_OUT_OF_RANGE` instead of `ERR_INDEX_OUT_OF_RANGE`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18790",
                    "description": "Negative `end` values throw an `ERR_INDEX_OUT_OF_RANGE` error."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18129",
                    "description": "Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/17427",
                    "description": "Specifying an invalid string for `value` triggers a thrown exception."
                  },
                  {
                    "version": "v5.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/4935",
                    "description": "The `encoding` parameter is supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`.",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to fill `buf`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to fill `buf`."
                    },
                    {
                      "textRaw": "`end` {integer} Where to stop filling `buf` (not inclusive). **Default:** [`buf.length`][].",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`][]",
                      "desc": "Where to stop filling `buf` (not inclusive)."
                    },
                    {
                      "textRaw": "`encoding` {string} The encoding for `value` if `value` is a string. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The encoding for `value` if `value` is a string."
                    }
                  ]
                }
              ],
              "desc": "<p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,\nthe entire <code>buf</code> will be filled:</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n\n// Fill a buffer with empty string\nconst c = Buffer.allocUnsafe(5).fill('');\n\nconsole.log(c.fill(''));\n// Prints: &#x3C;Buffer 00 00 00 00 00>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n\n// Fill a buffer with empty string\nconst c = Buffer.allocUnsafe(5).fill('');\n\nconsole.log(c.fill(''));\n// Prints: &#x3C;Buffer 00 00 00 00 00>\n</code></pre>\n<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a string, <code>Buffer</code>, or\ninteger. If the resulting integer is greater than <code>255</code> (decimal), <code>buf</code> will be\nfilled with <code>value &#x26; 255</code>.</p>\n<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,\nthen only the bytes of that character that fit into <code>buf</code> are written:</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with character that takes up two bytes in UTF-8.\n\nconsole.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n// Prints: &#x3C;Buffer c8 a2 c8 a2 c8>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Fill a `Buffer` with character that takes up two bytes in UTF-8.\n\nconsole.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n// Prints: &#x3C;Buffer c8 a2 c8 a2 c8>\n</code></pre>\n<p>If <code>value</code> contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: &#x3C;Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: &#x3C;Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: &#x3C;Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: &#x3C;Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n</code></pre>"
            },
            {
              "textRaw": "`buf.includes(value[, byteOffset][, encoding])`",
              "type": "method",
              "name": "includes",
              "meta": {
                "added": [
                  "v5.3.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} `true` if `value` was found in `buf`, `false` otherwise.",
                    "name": "return",
                    "type": "boolean",
                    "desc": "`true` if `value` was found in `buf`, `false` otherwise."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} What to search for.",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`. **Default:** `0`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is its encoding. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is its encoding."
                    }
                  ]
                }
              ],
              "desc": "<p>Equivalent to <a href=\"#bufindexofvalue-byteoffset-encoding\"><code>buf.indexOf() !== -1</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n</code></pre>"
            },
            {
              "textRaw": "`buf.indexOf(value[, byteOffset][, encoding])`",
              "type": "method",
              "name": "indexOf",
              "meta": {
                "added": [
                  "v1.5.0"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `value` can now be a `Uint8Array`."
                  },
                  {
                    "version": [
                      "v5.7.0",
                      "v4.4.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/4803",
                    "description": "When `encoding` is being passed, the `byteOffset` parameter is no longer required."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} What to search for.",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`. **Default:** `0`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
                    }
                  ]
                }
              ],
              "desc": "<p>If <code>value</code> is:</p>\n<ul>\n<li>a string, <code>value</code> is interpreted according to the character encoding in\n<code>encoding</code>.</li>\n<li>a <code>Buffer</code> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a>, <code>value</code> will be used in its entirety.\nTo compare a partial <code>Buffer</code>, use <a href=\"#bufsubarraystart-end\"><code>buf.subarray</code></a>.</li>\n<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer\nvalue between <code>0</code> and <code>255</code>.</li>\n</ul>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n</code></pre>\n<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a\n<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.</p>\n<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. If the result\nof coercion is <code>NaN</code> or <code>0</code>, then the entire buffer will be searched. This\nbehavior matches <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\"><code>String.prototype.indexOf()</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n</code></pre>\n<p>If <code>value</code> is an empty string or empty <code>Buffer</code> and <code>byteOffset</code> is less\nthan <code>buf.length</code>, <code>byteOffset</code> will be returned. If <code>value</code> is empty and\n<code>byteOffset</code> is at least <code>buf.length</code>, <code>buf.length</code> will be returned.</p>"
            },
            {
              "textRaw": "`buf.keys()`",
              "type": "method",
              "name": "keys",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator}",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>buf</code> keys (indices).</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nfor (const key of buf.keys()) {\n  console.log(key);\n}\n// Prints:\n//   0\n//   1\n//   2\n//   3\n//   4\n//   5\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('buffer');\n\nfor (const key of buf.keys()) {\n  console.log(key);\n}\n// Prints:\n//   0\n//   1\n//   2\n//   3\n//   4\n//   5\n</code></pre>"
            },
            {
              "textRaw": "`buf.lastIndexOf(value[, byteOffset][, encoding])`",
              "type": "method",
              "name": "lastIndexOf",
              "meta": {
                "added": [
                  "v6.0.0"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `value` can now be a `Uint8Array`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} What to search for.",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`. **Default:** `buf.length - 1`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`buf.length - 1`",
                      "desc": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
                    }
                  ]
                }
              ],
              "desc": "<p>Identical to <a href=\"#bufindexofvalue-byteoffset-encoding\"><code>buf.indexOf()</code></a>, except the last occurrence of <code>value</code> is found\nrather than the first occurrence.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n</code></pre>\n<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a\n<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.</p>\n<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. Any arguments\nthat coerce to <code>NaN</code>, like <code>{}</code> or <code>undefined</code>, will search the whole buffer.\nThis behavior matches <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf\"><code>String.prototype.lastIndexOf()</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0.\n// Prints: -1, equivalent to passing 0.\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0.\n// Prints: -1, equivalent to passing 0.\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n</code></pre>\n<p>If <code>value</code> is an empty string or empty <code>Buffer</code>, <code>byteOffset</code> will be returned.</p>"
            },
            {
              "textRaw": "`buf.readBigInt64BE([offset])`",
              "type": "method",
              "name": "readBigInt64BE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {bigint}",
                    "name": "return",
                    "type": "bigint"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed, big-endian 64-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed\nvalues.</p>"
            },
            {
              "textRaw": "`buf.readBigInt64LE([offset])`",
              "type": "method",
              "name": "readBigInt64LE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {bigint}",
                    "name": "return",
                    "type": "bigint"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed, little-endian 64-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed\nvalues.</p>"
            },
            {
              "textRaw": "`buf.readBigUInt64BE([offset])`",
              "type": "method",
              "name": "readBigUInt64BE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.10.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34960",
                    "description": "This function is also available as `buf.readBigUint64BE()`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {bigint}",
                    "name": "return",
                    "type": "bigint"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned, big-endian 64-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>This function is also available under the <code>readBigUint64BE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64BE(0));\n// Prints: 4294967295n\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64BE(0));\n// Prints: 4294967295n\n</code></pre>"
            },
            {
              "textRaw": "`buf.readBigUInt64LE([offset])`",
              "type": "method",
              "name": "readBigUInt64LE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.10.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34960",
                    "description": "This function is also available as `buf.readBigUint64LE()`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {bigint}",
                    "name": "return",
                    "type": "bigint"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned, little-endian 64-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>This function is also available under the <code>readBigUint64LE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64LE(0));\n// Prints: 18446744069414584320n\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64LE(0));\n// Prints: 18446744069414584320n\n</code></pre>"
            },
            {
              "textRaw": "`buf.readDoubleBE([offset])`",
              "type": "method",
              "name": "readDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit, big-endian double from <code>buf</code> at the specified <code>offset</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\n</code></pre>"
            },
            {
              "textRaw": "`buf.readDoubleLE([offset])`",
              "type": "method",
              "name": "readDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit, little-endian double from <code>buf</code> at the specified <code>offset</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readFloatBE([offset])`",
              "type": "method",
              "name": "readFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit, big-endian float from <code>buf</code> at the specified <code>offset</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\n</code></pre>"
            },
            {
              "textRaw": "`buf.readFloatLE([offset])`",
              "type": "method",
              "name": "readFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit, little-endian float from <code>buf</code> at the specified <code>offset</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readInt8([offset])`",
              "type": "method",
              "name": "readInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readInt16BE([offset])`",
              "type": "method",
              "name": "readInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed, big-endian 16-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\n</code></pre>"
            },
            {
              "textRaw": "`buf.readInt16LE([offset])`",
              "type": "method",
              "name": "readInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed, little-endian 16-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readInt32BE([offset])`",
              "type": "method",
              "name": "readInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed, big-endian 32-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\n</code></pre>"
            },
            {
              "textRaw": "`buf.readInt32LE([offset])`",
              "type": "method",
              "name": "readInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed, little-endian 32-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readIntBE(offset, byteLength)`",
              "type": "method",
              "name": "readIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a big-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readIntLE(offset, byteLength)`",
              "type": "method",
              "name": "readIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a little-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\n</code></pre>"
            },
            {
              "textRaw": "`buf.readUInt8([offset])`",
              "type": "method",
              "name": "readUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.readUint8()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>This function is also available under the <code>readUint8</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readUInt16BE([offset])`",
              "type": "method",
              "name": "readUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.readUint16BE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned, big-endian 16-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>This function is also available under the <code>readUint16BE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\n</code></pre>"
            },
            {
              "textRaw": "`buf.readUInt16LE([offset])`",
              "type": "method",
              "name": "readUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.readUint16LE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned, little-endian 16-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>This function is also available under the <code>readUint16LE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readUInt32BE([offset])`",
              "type": "method",
              "name": "readUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.readUint32BE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned, big-endian 32-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>This function is also available under the <code>readUint32BE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\n</code></pre>"
            },
            {
              "textRaw": "`buf.readUInt32LE([offset])`",
              "type": "method",
              "name": "readUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.readUint32LE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned, little-endian 32-bit integer from <code>buf</code> at the specified\n<code>offset</code>.</p>\n<p>This function is also available under the <code>readUint32LE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readUIntBE(offset, byteLength)`",
              "type": "method",
              "name": "readUIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.readUintBE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned big-endian integer supporting\nup to 48 bits of accuracy.</p>\n<p>This function is also available under the <code>readUintBE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.readUIntLE(offset, byteLength)`",
              "type": "method",
              "name": "readUIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.readUintLE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned, little-endian integer supporting\nup to 48 bits of accuracy.</p>\n<p>This function is also available under the <code>readUintLE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\n</code></pre>"
            },
            {
              "textRaw": "`buf.subarray([start[, end]])`",
              "type": "method",
              "name": "subarray",
              "meta": {
                "added": [
                  "v3.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`start` {integer} Where the new `Buffer` will start. **Default:** `0`.",
                      "name": "start",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where the new `Buffer` will start."
                    },
                    {
                      "textRaw": "`end` {integer} Where the new `Buffer` will end (not inclusive). **Default:** [`buf.length`][].",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`][]",
                      "desc": "Where the new `Buffer` will end (not inclusive)."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> that references the same memory as the original, but\noffset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n<p>Specifying <code>end</code> greater than <a href=\"#buflength\"><code>buf.length</code></a> will return the same result as\nthat of <code>end</code> equal to <a href=\"#buflength\"><code>buf.length</code></a>.</p>\n<p>This method is inherited from <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray\"><code>TypedArray.prototype.subarray()</code></a>.</p>\n<p>Modifying the new <code>Buffer</code> slice will modify the memory in the original <code>Buffer</code>\nbecause the allocated memory of the two objects overlap.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\n// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.subarray(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\n// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.subarray(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n</code></pre>\n<p>Specifying negative indexes causes the slice to be generated relative to the\nend of <code>buf</code> rather than the beginning.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.subarray(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.subarray(0, 5).)\n\nconsole.log(buf.subarray(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.subarray(0, 4).)\n\nconsole.log(buf.subarray(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.subarray(1, 4).)\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.subarray(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.subarray(0, 5).)\n\nconsole.log(buf.subarray(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.subarray(0, 4).)\n\nconsole.log(buf.subarray(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.subarray(1, 4).)\n</code></pre>"
            },
            {
              "textRaw": "`buf.slice([start[, end]])`",
              "type": "method",
              "name": "slice",
              "meta": {
                "added": [
                  "v0.3.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v17.5.0",
                      "v16.15.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/41596",
                    "description": "The buf.slice() method has been deprecated."
                  },
                  {
                    "version": [
                      "v7.1.0",
                      "v6.9.2"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/9341",
                    "description": "Coercing the offsets to integers now handles values outside the 32-bit integer range properly."
                  },
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/9101",
                    "description": "All offsets are now coerced to integers before doing any calculations with them."
                  }
                ]
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`buf.subarray`][] instead.",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`start` {integer} Where the new `Buffer` will start. **Default:** `0`.",
                      "name": "start",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where the new `Buffer` will start."
                    },
                    {
                      "textRaw": "`end` {integer} Where the new `Buffer` will end (not inclusive). **Default:** [`buf.length`][].",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`][]",
                      "desc": "Where the new `Buffer` will end (not inclusive)."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> that references the same memory as the original, but\noffset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n<p>This method is not compatible with the <code>Uint8Array.prototype.slice()</code>,\nwhich is a superclass of <code>Buffer</code>. To copy the slice, use\n<code>Uint8Array.prototype.slice()</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconst copiedBuf = Uint8Array.prototype.slice.call(buf);\ncopiedBuf[0]++;\nconsole.log(copiedBuf.toString());\n// Prints: cuffer\n\nconsole.log(buf.toString());\n// Prints: buffer\n\n// With buf.slice(), the original buffer is modified.\nconst notReallyCopiedBuf = buf.slice();\nnotReallyCopiedBuf[0]++;\nconsole.log(notReallyCopiedBuf.toString());\n// Prints: cuffer\nconsole.log(buf.toString());\n// Also prints: cuffer (!)\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('buffer');\n\nconst copiedBuf = Uint8Array.prototype.slice.call(buf);\ncopiedBuf[0]++;\nconsole.log(copiedBuf.toString());\n// Prints: cuffer\n\nconsole.log(buf.toString());\n// Prints: buffer\n\n// With buf.slice(), the original buffer is modified.\nconst notReallyCopiedBuf = buf.slice();\nnotReallyCopiedBuf[0]++;\nconsole.log(notReallyCopiedBuf.toString());\n// Prints: cuffer\nconsole.log(buf.toString());\n// Also prints: cuffer (!)\n</code></pre>"
            },
            {
              "textRaw": "`buf.swap16()`",
              "type": "method",
              "name": "swap16",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the\nbyte order <em>in-place</em>. Throws <a href=\"errors.html#err_invalid_buffer_size\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buflength\"><code>buf.length</code></a>\nis not a multiple of 2.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE.\n</code></pre>\n<p>One convenient use of <code>buf.swap16()</code> is to perform a fast in-place conversion\nbetween UTF-16 little-endian and UTF-16 big-endian:</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n</code></pre>"
            },
            {
              "textRaw": "`buf.swap32()`",
              "type": "method",
              "name": "swap32",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the\nbyte order <em>in-place</em>. Throws <a href=\"errors.html#err_invalid_buffer_size\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buflength\"><code>buf.length</code></a>\nis not a multiple of 4.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.swap64()`",
              "type": "method",
              "name": "swap64",
              "meta": {
                "added": [
                  "v6.3.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps byte order <em>in-place</em>.\nThrows <a href=\"errors.html#err_invalid_buffer_size\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buflength\"><code>buf.length</code></a> is not a multiple of 8.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE.\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE.\n</code></pre>"
            },
            {
              "textRaw": "`buf.toJSON()`",
              "type": "method",
              "name": "toJSON",
              "meta": {
                "added": [
                  "v0.9.2"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns a JSON representation of <code>buf</code>. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a> implicitly calls\nthis function when stringifying a <code>Buffer</code> instance.</p>\n<p><code>Buffer.from()</code> accepts objects in the format returned from this method.\nIn particular, <code>Buffer.from(buf.toJSON())</code> works like <code>Buffer.from(buf)</code>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: &#x3C;Buffer 01 02 03 04 05>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: &#x3C;Buffer 01 02 03 04 05>\n</code></pre>"
            },
            {
              "textRaw": "`buf.toString([encoding[, start[, end]]])`",
              "type": "method",
              "name": "toString",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string}",
                    "name": "return",
                    "type": "string"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {string} The character encoding to use. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The character encoding to use."
                    },
                    {
                      "textRaw": "`start` {integer} The byte offset to start decoding at. **Default:** `0`.",
                      "name": "start",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The byte offset to start decoding at."
                    },
                    {
                      "textRaw": "`end` {integer} The byte offset to stop decoding at (not inclusive). **Default:** [`buf.length`][].",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`][]",
                      "desc": "The byte offset to stop decoding at (not inclusive)."
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes <code>buf</code> to a string according to the specified character encoding in\n<code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>\n<p>If <code>encoding</code> is <code>'utf8'</code> and a byte sequence in the input is not valid UTF-8,\nthen each invalid byte is replaced with the replacement character <code>U+FFFD</code>.</p>\n<p>The maximum length of a string instance (in UTF-16 code units) is available\nas <a href=\"#bufferconstantsmax_string_length\"><code>buffer.constants.MAX_STRING_LENGTH</code></a>.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconsole.log(buf1.toString('utf8'));\n// Prints: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf1.toString('utf8', 0, 5));\n// Prints: abcde\n\nconst buf2 = Buffer.from('tést');\n\nconsole.log(buf2.toString('hex'));\n// Prints: 74c3a97374\nconsole.log(buf2.toString('utf8', 0, 3));\n// Prints: té\nconsole.log(buf2.toString(undefined, 0, 3));\n// Prints: té\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconsole.log(buf1.toString('utf8'));\n// Prints: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf1.toString('utf8', 0, 5));\n// Prints: abcde\n\nconst buf2 = Buffer.from('tést');\n\nconsole.log(buf2.toString('hex'));\n// Prints: 74c3a97374\nconsole.log(buf2.toString('utf8', 0, 3));\n// Prints: té\nconsole.log(buf2.toString(undefined, 0, 3));\n// Prints: té\n</code></pre>"
            },
            {
              "textRaw": "`buf.values()`",
              "type": "method",
              "name": "values",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator}",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> for <code>buf</code> values (bytes). This function is\ncalled automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nfor (const value of buf.values()) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n\nfor (const value of buf) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.from('buffer');\n\nfor (const value of buf.values()) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n\nfor (const value of buf) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n</code></pre>"
            },
            {
              "textRaw": "`buf.write(string[, offset[, length]][, encoding])`",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} Number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "Number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`string` {string} String to write to `buf`.",
                      "name": "string",
                      "type": "string",
                      "desc": "String to write to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write `string`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write `string`."
                    },
                    {
                      "textRaw": "`length` {integer} Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`). **Default:** `buf.length - offset`.",
                      "name": "length",
                      "type": "integer",
                      "default": "`buf.length - offset`",
                      "desc": "Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`)."
                    },
                    {
                      "textRaw": "`encoding` {string} The character encoding of `string`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The character encoding of `string`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in\n<code>encoding</code>. The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did\nnot contain enough space to fit the entire string, only part of <code>string</code> will be\nwritten. However, partially encoded characters will not be written.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes: ½ + ¼ = ¾\n\nconst buffer = Buffer.alloc(10);\n\nconst length = buffer.write('abcd', 8);\n\nconsole.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n// Prints: 2 bytes : ab\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes: ½ + ¼ = ¾\n\nconst buffer = Buffer.alloc(10);\n\nconst length = buffer.write('abcd', 8);\n\nconsole.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n// Prints: 2 bytes : ab\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeBigInt64BE(value[, offset])`",
              "type": "method",
              "name": "writeBigInt64BE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {bigint} Number to be written to `buf`.",
                      "name": "value",
                      "type": "bigint",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64BE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64BE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeBigInt64LE(value[, offset])`",
              "type": "method",
              "name": "writeBigInt64LE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {bigint} Number to be written to `buf`.",
                      "name": "value",
                      "type": "bigint",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64LE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 08 07 06 05 04 03 02 01>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64LE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 08 07 06 05 04 03 02 01>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeBigUInt64BE(value[, offset])`",
              "type": "method",
              "name": "writeBigUInt64BE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.10.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34960",
                    "description": "This function is also available as `buf.writeBigUint64BE()`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {bigint} Number to be written to `buf`.",
                      "name": "value",
                      "type": "bigint",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian.</p>\n<p>This function is also available under the <code>writeBigUint64BE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de ca fa fe ca ce fa de>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de ca fa fe ca ce fa de>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeBigUInt64LE(value[, offset])`",
              "type": "method",
              "name": "writeBigUInt64LE",
              "meta": {
                "added": [
                  "v12.0.0",
                  "v10.20.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.10.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34960",
                    "description": "This function is also available as `buf.writeBigUint64LE()`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {bigint} Number to be written to `buf`.",
                      "name": "value",
                      "type": "bigint",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de fa ce ca fe fa ca de>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de fa ce ca fe fa ca de>\n</code></pre>\n<p>This function is also available under the <code>writeBigUint64LE</code> alias.</p>"
            },
            {
              "textRaw": "`buf.writeDoubleBE(value[, offset])`",
              "type": "method",
              "name": "writeDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>\nmust be a JavaScript number. Behavior is undefined when <code>value</code> is anything\nother than a JavaScript number.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 40 5e dd 2f 1a 9f be 77>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 40 5e dd 2f 1a 9f be 77>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeDoubleLE(value[, offset])`",
              "type": "method",
              "name": "writeDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>\nmust be a JavaScript number. Behavior is undefined when <code>value</code> is anything\nother than a JavaScript number.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 77 be 9f 1a 2f dd 5e 40>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 77 be 9f 1a 2f dd 5e 40>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeFloatBE(value[, offset])`",
              "type": "method",
              "name": "writeFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. Behavior is\nundefined when <code>value</code> is anything other than a JavaScript number.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 4f 4a fe bb>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 4f 4a fe bb>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeFloatLE(value[, offset])`",
              "type": "method",
              "name": "writeFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. Behavior is\nundefined when <code>value</code> is anything other than a JavaScript number.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer bb fe 4a 4f>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer bb fe 4a 4f>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeInt8(value[, offset])`",
              "type": "method",
              "name": "writeInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid\nsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything other than\na signed 8-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 02 fe>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 02 fe>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeInt16BE(value[, offset])`",
              "type": "method",
              "name": "writeInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian.  The <code>value</code>\nmust be a valid signed 16-bit integer. Behavior is undefined when <code>value</code> is\nanything other than a signed 16-bit integer.</p>\n<p>The <code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16BE(0x0102, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16BE(0x0102, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeInt16LE(value[, offset])`",
              "type": "method",
              "name": "writeInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian.  The <code>value</code>\nmust be a valid signed 16-bit integer. Behavior is undefined when <code>value</code> is\nanything other than a signed 16-bit integer.</p>\n<p>The <code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16LE(0x0304, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 04 03>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16LE(0x0304, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 04 03>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeInt32BE(value[, offset])`",
              "type": "method",
              "name": "writeInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>\nmust be a valid signed 32-bit integer. Behavior is undefined when <code>value</code> is\nanything other than a signed 32-bit integer.</p>\n<p>The <code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32BE(0x01020304, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 03 04>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32BE(0x01020304, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 03 04>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeInt32LE(value[, offset])`",
              "type": "method",
              "name": "writeInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>\nmust be a valid signed 32-bit integer. Behavior is undefined when <code>value</code> is\nanything other than a signed 32-bit integer.</p>\n<p>The <code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32LE(0x05060708, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 08 07 06 05>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32LE(0x05060708, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 08 07 06 05>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeIntBE(value, offset, byteLength)`",
              "type": "method",
              "name": "writeIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>\nas big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when\n<code>value</code> is anything other than a signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeIntLE(value, offset, byteLength)`",
              "type": "method",
              "name": "writeIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>\nas little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen <code>value</code> is anything other than a signed integer.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeUInt8(value[, offset])`",
              "type": "method",
              "name": "writeUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.writeUint8()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a\nvalid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything\nother than an unsigned 8-bit integer.</p>\n<p>This function is also available under the <code>writeUint8</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 03 04 23 42>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 03 04 23 42>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeUInt16BE(value[, offset])`",
              "type": "method",
              "name": "writeUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.writeUint16BE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>\nmust be a valid unsigned 16-bit integer. Behavior is undefined when <code>value</code>\nis anything other than an unsigned 16-bit integer.</p>\n<p>This function is also available under the <code>writeUint16BE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de ad be ef>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de ad be ef>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeUInt16LE(value[, offset])`",
              "type": "method",
              "name": "writeUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.writeUint16LE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>\nmust be a valid unsigned 16-bit integer. Behavior is undefined when <code>value</code> is\nanything other than an unsigned 16-bit integer.</p>\n<p>This function is also available under the <code>writeUint16LE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ad de ef be>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ad de ef be>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeUInt32BE(value[, offset])`",
              "type": "method",
              "name": "writeUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.writeUint32BE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>\nmust be a valid unsigned 32-bit integer. Behavior is undefined when <code>value</code>\nis anything other than an unsigned 32-bit integer.</p>\n<p>This function is also available under the <code>writeUint32BE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer fe ed fa ce>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer fe ed fa ce>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeUInt32LE(value[, offset])`",
              "type": "method",
              "name": "writeUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.writeUint32LE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>\nmust be a valid unsigned 32-bit integer. Behavior is undefined when <code>value</code> is\nanything other than an unsigned 32-bit integer.</p>\n<p>This function is also available under the <code>writeUint32LE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ce fa ed fe>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ce fa ed fe>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeUIntBE(value, offset, byteLength)`",
              "type": "method",
              "name": "writeUIntBE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.writeUintBE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>\nas big-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen <code>value</code> is anything other than an unsigned integer.</p>\n<p>This function is also available under the <code>writeUintBE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n</code></pre>"
            },
            {
              "textRaw": "`buf.writeUIntLE(value, offset, byteLength)`",
              "type": "method",
              "name": "writeUIntLE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": [
                      "v14.9.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/34729",
                    "description": "This function is also available as `buf.writeUintLE()`."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>\nas little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen <code>value</code> is anything other than an unsigned integer.</p>\n<p>This function is also available under the <code>writeUintLE</code> alias.</p>\n<pre><code class=\"language-mjs\">import { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>\n<pre><code class=\"language-cjs\">const { Buffer } = require('node:buffer');\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`array` {integer\\[]} An array of bytes to copy from.",
                  "name": "array",
                  "type": "integer\\[]",
                  "desc": "An array of bytes to copy from."
                }
              ],
              "desc": "<p>See <a href=\"#static-method-bufferfromarray\"><code>Buffer.from(array)</code></a>.</p>"
            },
            {
              "params": [
                {
                  "textRaw": "`arrayBuffer` {ArrayBuffer|SharedArrayBuffer} An [`ArrayBuffer`][], [`SharedArrayBuffer`][] or the `.buffer` property of a [`TypedArray`][].",
                  "name": "arrayBuffer",
                  "type": "ArrayBuffer|SharedArrayBuffer",
                  "desc": "An [`ArrayBuffer`][], [`SharedArrayBuffer`][] or the `.buffer` property of a [`TypedArray`][]."
                },
                {
                  "textRaw": "`byteOffset` {integer} Index of first byte to expose. **Default:** `0`.",
                  "name": "byteOffset",
                  "type": "integer",
                  "default": "`0`",
                  "desc": "Index of first byte to expose."
                },
                {
                  "textRaw": "`length` {integer} Number of bytes to expose. **Default:** `arrayBuffer.byteLength - byteOffset`.",
                  "name": "length",
                  "type": "integer",
                  "default": "`arrayBuffer.byteLength - byteOffset`",
                  "desc": "Number of bytes to expose."
                }
              ],
              "desc": "<p>See\n<a href=\"#static-method-bufferfromarraybuffer-byteoffset-length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>.</p>"
            },
            {
              "params": [
                {
                  "textRaw": "`buffer` {Buffer|Uint8Array} An existing `Buffer` or [`Uint8Array`][] from which to copy data.",
                  "name": "buffer",
                  "type": "Buffer|Uint8Array",
                  "desc": "An existing `Buffer` or [`Uint8Array`][] from which to copy data."
                }
              ],
              "desc": "<p>See <a href=\"#static-method-bufferfrombuffer\"><code>Buffer.from(buffer)</code></a>.</p>"
            },
            {
              "params": [
                {
                  "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                  "name": "size",
                  "type": "integer",
                  "desc": "The desired length of the new `Buffer`."
                }
              ],
              "desc": "<p>See <a href=\"#static-method-bufferallocsize-fill-encoding\"><code>Buffer.alloc()</code></a> and <a href=\"#static-method-bufferallocunsafesize\"><code>Buffer.allocUnsafe()</code></a>. This variant of the\nconstructor is equivalent to <a href=\"#static-method-bufferallocsize-fill-encoding\"><code>Buffer.alloc()</code></a>.</p>"
            },
            {
              "params": [
                {
                  "textRaw": "`string` {string} String to encode.",
                  "name": "string",
                  "type": "string",
                  "desc": "String to encode."
                },
                {
                  "textRaw": "`encoding` {string} The encoding of `string`. **Default:** `'utf8'`.",
                  "name": "encoding",
                  "type": "string",
                  "default": "`'utf8'`",
                  "desc": "The encoding of `string`."
                }
              ],
              "desc": "<p>See <a href=\"#static-method-bufferfromstring-encoding\"><code>Buffer.from(string[, encoding])</code></a>.</p>"
            }
          ]
        },
        {
          "textRaw": "Class: `File`",
          "type": "class",
          "name": "File",
          "meta": {
            "added": [
              "v19.2.0",
              "v18.13.0"
            ],
            "changes": []
          },
          "stability": 1,
          "stabilityText": "Experimental",
          "desc": "<ul>\n<li>Extends: <a href=\"buffer.html#class-blob\" class=\"type\">&lt;Blob&gt;</a></li>\n</ul>\n<p>A <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/File\"><code>File</code></a> provides information about files.</p>",
          "properties": [
            {
              "textRaw": "`name` Type: {string}",
              "type": "string",
              "name": "Type",
              "meta": {
                "added": [
                  "v19.2.0",
                  "v18.13.0"
                ],
                "changes": []
              },
              "desc": "<p>The name of the <code>File</code>.</p>"
            },
            {
              "textRaw": "`lastModified` Type: {number}",
              "type": "number",
              "name": "Type",
              "meta": {
                "added": [
                  "v19.2.0",
                  "v18.13.0"
                ],
                "changes": []
              },
              "desc": "<p>The last modified date of the <code>File</code>.</p>"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`sources` {string\\[]|ArrayBuffer\\[]|TypedArray\\[]|DataView\\[]|Blob\\[]|File\\[]} An array of string, {ArrayBuffer}, {TypedArray}, {DataView}, {File}, or {Blob} objects, or any mix of such objects, that will be stored within the `File`.",
                  "name": "sources",
                  "type": "string\\[]|ArrayBuffer\\[]|TypedArray\\[]|DataView\\[]|Blob\\[]|File\\[]",
                  "desc": "An array of string, {ArrayBuffer}, {TypedArray}, {DataView}, {File}, or {Blob} objects, or any mix of such objects, that will be stored within the `File`."
                },
                {
                  "textRaw": "`fileName` {string} The name of the file.",
                  "name": "fileName",
                  "type": "string",
                  "desc": "The name of the file."
                },
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`endings` {string} One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be converted to the platform native line-ending as specified by `require('node:os').EOL`.",
                      "name": "endings",
                      "type": "string",
                      "desc": "One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be converted to the platform native line-ending as specified by `require('node:os').EOL`."
                    },
                    {
                      "textRaw": "`type` {string} The File content-type.",
                      "name": "type",
                      "type": "string",
                      "desc": "The File content-type."
                    },
                    {
                      "textRaw": "`lastModified` {number} The last modified date of the file. **Default:** `Date.now()`.",
                      "name": "lastModified",
                      "type": "number",
                      "default": "`Date.now()`",
                      "desc": "The last modified date of the file."
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    }
  ]
}