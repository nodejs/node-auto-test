{
  "type": "module",
  "source": "doc/api/dgram.md",
  "modules": [
    {
      "textRaw": "UDP/datagram sockets",
      "name": "dgram",
      "introduced_in": "v0.10.0",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p><strong>Source Code:</strong> <a href=\"https://github.com/nodejs/node/blob/v20.0.0/lib/dgram.js\">lib/dgram.js</a></p>\n<p>The <code>node:dgram</code> module provides an implementation of UDP datagram sockets.</p>\n<pre><code class=\"language-mjs\">import dgram from 'node:dgram';\n\nconst server = dgram.createSocket('udp4');\n\nserver.on('error', (err) => {\n  console.error(`server error:\\n${err.stack}`);\n  server.close();\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\n\nserver.bind(41234);\n// Prints: server listening 0.0.0.0:41234\n</code></pre>\n<pre><code class=\"language-cjs\">const dgram = require('node:dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('error', (err) => {\n  console.error(`server error:\\n${err.stack}`);\n  server.close();\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\n\nserver.bind(41234);\n// Prints: server listening 0.0.0.0:41234\n</code></pre>",
      "classes": [
        {
          "textRaw": "Class: `dgram.Socket`",
          "type": "class",
          "name": "dgram.Socket",
          "meta": {
            "added": [
              "v0.1.99"
            ],
            "changes": []
          },
          "desc": "<ul>\n<li>Extends: <a href=\"events.html#class-eventemitter\" class=\"type\">&lt;EventEmitter&gt;</a></li>\n</ul>\n<p>Encapsulates the datagram functionality.</p>\n<p>New instances of <code>dgram.Socket</code> are created using <a href=\"#dgramcreatesocketoptions-callback\"><code>dgram.createSocket()</code></a>.\nThe <code>new</code> keyword is not to be used to create <code>dgram.Socket</code> instances.</p>",
          "events": [
            {
              "textRaw": "Event: `'close'`",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'close'</code> event is emitted after a socket is closed with <a href=\"#socketclosecallback\"><code>close()</code></a>.\nOnce triggered, no new <code>'message'</code> events will be emitted on this socket.</p>"
            },
            {
              "textRaw": "Event: `'connect'`",
              "type": "event",
              "name": "connect",
              "meta": {
                "added": [
                  "v12.0.0"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'connect'</code> event is emitted after a socket is associated to a remote\naddress as a result of a successful <a href=\"#socketconnectport-address-callback\"><code>connect()</code></a> call.</p>"
            },
            {
              "textRaw": "Event: `'error'`",
              "type": "event",
              "name": "error",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": []
              },
              "params": [
                {
                  "textRaw": "`exception` {Error}",
                  "name": "exception",
                  "type": "Error"
                }
              ],
              "desc": "<p>The <code>'error'</code> event is emitted whenever any error occurs. The event handler\nfunction is passed a single <code>Error</code> object.</p>"
            },
            {
              "textRaw": "Event: `'listening'`",
              "type": "event",
              "name": "listening",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'listening'</code> event is emitted once the <code>dgram.Socket</code> is addressable and\ncan receive data. This happens either explicitly with <code>socket.bind()</code> or\nimplicitly the first time data is sent using <code>socket.send()</code>.\nUntil the <code>dgram.Socket</code> is listening, the underlying system resources do not\nexist and calls such as <code>socket.address()</code> and <code>socket.setTTL()</code> will fail.</p>"
            },
            {
              "textRaw": "Event: `'message'`",
              "type": "event",
              "name": "message",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": [
                  {
                    "version": "v18.4.0",
                    "pr-url": "https://github.com/nodejs/node/pull/43054",
                    "description": "The `family` property now returns a string instead of a number."
                  },
                  {
                    "version": "v18.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/41431",
                    "description": "The `family` property now returns a number instead of a string."
                  }
                ]
              },
              "params": [],
              "desc": "<p>The <code>'message'</code> event is emitted when a new datagram is available on a socket.\nThe event handler function is passed two arguments: <code>msg</code> and <code>rinfo</code>.</p>\n<ul>\n<li><code>msg</code> <a href=\"buffer.html#class-buffer\" class=\"type\">&lt;Buffer&gt;</a> The message.</li>\n<li><code>rinfo</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\" class=\"type\">&lt;Object&gt;</a> Remote address information.\n<ul>\n<li><code>address</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> The sender address.</li>\n<li><code>family</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> The address family (<code>'IPv4'</code> or <code>'IPv6'</code>).</li>\n<li><code>port</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The sender port.</li>\n<li><code>size</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The message size.</li>\n</ul>\n</li>\n</ul>\n<p>If the source address of the incoming packet is an IPv6 link-local\naddress, the interface name is added to the <code>address</code>. For\nexample, a packet received on the <code>en0</code> interface might have the\naddress field set to <code>'fe80::2618:1234:ab11:3b9c%en0'</code>, where <code>'%en0'</code>\nis the interface name as a zone ID suffix.</p>"
            }
          ],
          "methods": [
            {
              "textRaw": "`socket.addMembership(multicastAddress[, multicastInterface])`",
              "type": "method",
              "name": "addMembership",
              "meta": {
                "added": [
                  "v0.6.9"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`multicastAddress` {string}",
                      "name": "multicastAddress",
                      "type": "string"
                    },
                    {
                      "textRaw": "`multicastInterface` {string}",
                      "name": "multicastInterface",
                      "type": "string"
                    }
                  ]
                }
              ],
              "desc": "<p>Tells the kernel to join a multicast group at the given <code>multicastAddress</code> and\n<code>multicastInterface</code> using the <code>IP_ADD_MEMBERSHIP</code> socket option. If the\n<code>multicastInterface</code> argument is not specified, the operating system will choose\none interface and will add membership to it. To add membership to every\navailable interface, call <code>addMembership</code> multiple times, once per interface.</p>\n<p>When called on an unbound socket, this method will implicitly bind to a random\nport, listening on all interfaces.</p>\n<p>When sharing a UDP socket across multiple <code>cluster</code> workers, the\n<code>socket.addMembership()</code> function must be called only once or an\n<code>EADDRINUSE</code> error will occur:</p>\n<pre><code class=\"language-mjs\">import cluster from 'node:cluster';\nimport dgram from 'node:dgram';\n\nif (cluster.isPrimary) {\n  cluster.fork(); // Works ok.\n  cluster.fork(); // Fails with EADDRINUSE.\n} else {\n  const s = dgram.createSocket('udp4');\n  s.bind(1234, () => {\n    s.addMembership('224.0.0.114');\n  });\n}\n</code></pre>\n<pre><code class=\"language-cjs\">const cluster = require('node:cluster');\nconst dgram = require('node:dgram');\n\nif (cluster.isPrimary) {\n  cluster.fork(); // Works ok.\n  cluster.fork(); // Fails with EADDRINUSE.\n} else {\n  const s = dgram.createSocket('udp4');\n  s.bind(1234, () => {\n    s.addMembership('224.0.0.114');\n  });\n}\n</code></pre>"
            },
            {
              "textRaw": "`socket.addSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])`",
              "type": "method",
              "name": "addSourceSpecificMembership",
              "meta": {
                "added": [
                  "v13.1.0",
                  "v12.16.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`sourceAddress` {string}",
                      "name": "sourceAddress",
                      "type": "string"
                    },
                    {
                      "textRaw": "`groupAddress` {string}",
                      "name": "groupAddress",
                      "type": "string"
                    },
                    {
                      "textRaw": "`multicastInterface` {string}",
                      "name": "multicastInterface",
                      "type": "string"
                    }
                  ]
                }
              ],
              "desc": "<p>Tells the kernel to join a source-specific multicast channel at the given\n<code>sourceAddress</code> and <code>groupAddress</code>, using the <code>multicastInterface</code> with the\n<code>IP_ADD_SOURCE_MEMBERSHIP</code> socket option. If the <code>multicastInterface</code> argument\nis not specified, the operating system will choose one interface and will add\nmembership to it. To add membership to every available interface, call\n<code>socket.addSourceSpecificMembership()</code> multiple times, once per interface.</p>\n<p>When called on an unbound socket, this method will implicitly bind to a random\nport, listening on all interfaces.</p>"
            },
            {
              "textRaw": "`socket.address()`",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns an object containing the address information for a socket.\nFor UDP sockets, this object will contain <code>address</code>, <code>family</code>, and <code>port</code>\nproperties.</p>\n<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.bind([port][, address][, callback])`",
              "type": "method",
              "name": "bind",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": [
                  {
                    "version": "v0.9.1",
                    "commit": "332fea5ac1816e498030109c4211bca24a7fa667",
                    "description": "The method was changed to an asynchronous execution model. Legacy code would need to be changed to pass a callback function to the method call."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`port` {integer}",
                      "name": "port",
                      "type": "integer"
                    },
                    {
                      "textRaw": "`address` {string}",
                      "name": "address",
                      "type": "string"
                    },
                    {
                      "textRaw": "`callback` {Function} with no parameters. Called when binding is complete.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "with no parameters. Called when binding is complete."
                    }
                  ]
                }
              ],
              "desc": "<p>For UDP sockets, causes the <code>dgram.Socket</code> to listen for datagram\nmessages on a named <code>port</code> and optional <code>address</code>. If <code>port</code> is not\nspecified or is <code>0</code>, the operating system will attempt to bind to a\nrandom port. If <code>address</code> is not specified, the operating system will\nattempt to listen on all addresses. Once binding is complete, a\n<code>'listening'</code> event is emitted and the optional <code>callback</code> function is\ncalled.</p>\n<p>Specifying both a <code>'listening'</code> event listener and passing a\n<code>callback</code> to the <code>socket.bind()</code> method is not harmful but not very\nuseful.</p>\n<p>A bound datagram socket keeps the Node.js process running to receive\ndatagram messages.</p>\n<p>If binding fails, an <code>'error'</code> event is generated. In rare case (e.g.\nattempting to bind with a closed socket), an <a href=\"errors.html#class-error\"><code>Error</code></a> may be thrown.</p>\n<p>Example of a UDP server listening on port 41234:</p>\n<pre><code class=\"language-mjs\">import dgram from 'node:dgram';\n\nconst server = dgram.createSocket('udp4');\n\nserver.on('error', (err) => {\n  console.error(`server error:\\n${err.stack}`);\n  server.close();\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\n\nserver.bind(41234);\n// Prints: server listening 0.0.0.0:41234\n</code></pre>\n<pre><code class=\"language-cjs\">const dgram = require('node:dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('error', (err) => {\n  console.error(`server error:\\n${err.stack}`);\n  server.close();\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\n\nserver.bind(41234);\n// Prints: server listening 0.0.0.0:41234\n</code></pre>"
            },
            {
              "textRaw": "`socket.bind(options[, callback])`",
              "type": "method",
              "name": "bind",
              "meta": {
                "added": [
                  "v0.11.14"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} Required. Supports the following properties:",
                      "name": "options",
                      "type": "Object",
                      "desc": "Required. Supports the following properties:",
                      "options": [
                        {
                          "textRaw": "`port` {integer}",
                          "name": "port",
                          "type": "integer"
                        },
                        {
                          "textRaw": "`address` {string}",
                          "name": "address",
                          "type": "string"
                        },
                        {
                          "textRaw": "`exclusive` {boolean}",
                          "name": "exclusive",
                          "type": "boolean"
                        },
                        {
                          "textRaw": "`fd` {integer}",
                          "name": "fd",
                          "type": "integer"
                        }
                      ]
                    },
                    {
                      "textRaw": "`callback` {Function}",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                }
              ],
              "desc": "<p>For UDP sockets, causes the <code>dgram.Socket</code> to listen for datagram\nmessages on a named <code>port</code> and optional <code>address</code> that are passed as\nproperties of an <code>options</code> object passed as the first argument. If\n<code>port</code> is not specified or is <code>0</code>, the operating system will attempt\nto bind to a random port. If <code>address</code> is not specified, the operating\nsystem will attempt to listen on all addresses. Once binding is\ncomplete, a <code>'listening'</code> event is emitted and the optional <code>callback</code>\nfunction is called.</p>\n<p>The <code>options</code> object may contain a <code>fd</code> property. When a <code>fd</code> greater\nthan <code>0</code> is set, it will wrap around an existing socket with the given\nfile descriptor. In this case, the properties of <code>port</code> and <code>address</code>\nwill be ignored.</p>\n<p>Specifying both a <code>'listening'</code> event listener and passing a\n<code>callback</code> to the <code>socket.bind()</code> method is not harmful but not very\nuseful.</p>\n<p>The <code>options</code> object may contain an additional <code>exclusive</code> property that is\nused when using <code>dgram.Socket</code> objects with the <a href=\"cluster.html\"><code>cluster</code></a> module. When\n<code>exclusive</code> is set to <code>false</code> (the default), cluster workers will use the same\nunderlying socket handle allowing connection handling duties to be shared.\nWhen <code>exclusive</code> is <code>true</code>, however, the handle is not shared and attempted\nport sharing results in an error.</p>\n<p>A bound datagram socket keeps the Node.js process running to receive\ndatagram messages.</p>\n<p>If binding fails, an <code>'error'</code> event is generated. In rare case (e.g.\nattempting to bind with a closed socket), an <a href=\"errors.html#class-error\"><code>Error</code></a> may be thrown.</p>\n<p>An example socket listening on an exclusive port is shown below.</p>\n<pre><code class=\"language-js\">socket.bind({\n  address: 'localhost',\n  port: 8000,\n  exclusive: true,\n});\n</code></pre>"
            },
            {
              "textRaw": "`socket.close([callback])`",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`callback` {Function} Called when the socket has been closed.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Called when the socket has been closed."
                    }
                  ]
                }
              ],
              "desc": "<p>Close the underlying socket and stop listening for data on it. If a callback is\nprovided, it is added as a listener for the <a href=\"#event-close\"><code>'close'</code></a> event.</p>"
            },
            {
              "textRaw": "`socket.connect(port[, address][, callback])`",
              "type": "method",
              "name": "connect",
              "meta": {
                "added": [
                  "v12.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`port` {integer}",
                      "name": "port",
                      "type": "integer"
                    },
                    {
                      "textRaw": "`address` {string}",
                      "name": "address",
                      "type": "string"
                    },
                    {
                      "textRaw": "`callback` {Function} Called when the connection is completed or on error.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Called when the connection is completed or on error."
                    }
                  ]
                }
              ],
              "desc": "<p>Associates the <code>dgram.Socket</code> to a remote address and port. Every\nmessage sent by this handle is automatically sent to that destination. Also,\nthe socket will only receive messages from that remote peer.\nTrying to call <code>connect()</code> on an already connected socket will result\nin an <a href=\"errors.html#err_socket_dgram_is_connected\"><code>ERR_SOCKET_DGRAM_IS_CONNECTED</code></a> exception. If <code>address</code> is not\nprovided, <code>'127.0.0.1'</code> (for <code>udp4</code> sockets) or <code>'::1'</code> (for <code>udp6</code> sockets)\nwill be used by default. Once the connection is complete, a <code>'connect'</code> event\nis emitted and the optional <code>callback</code> function is called. In case of failure,\nthe <code>callback</code> is called or, failing this, an <code>'error'</code> event is emitted.</p>"
            },
            {
              "textRaw": "`socket.disconnect()`",
              "type": "method",
              "name": "disconnect",
              "meta": {
                "added": [
                  "v12.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>A synchronous function that disassociates a connected <code>dgram.Socket</code> from\nits remote address. Trying to call <code>disconnect()</code> on an unbound or already\ndisconnected socket will result in an <a href=\"errors.html#err_socket_dgram_not_connected\"><code>ERR_SOCKET_DGRAM_NOT_CONNECTED</code></a>\nexception.</p>"
            },
            {
              "textRaw": "`socket.dropMembership(multicastAddress[, multicastInterface])`",
              "type": "method",
              "name": "dropMembership",
              "meta": {
                "added": [
                  "v0.6.9"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`multicastAddress` {string}",
                      "name": "multicastAddress",
                      "type": "string"
                    },
                    {
                      "textRaw": "`multicastInterface` {string}",
                      "name": "multicastInterface",
                      "type": "string"
                    }
                  ]
                }
              ],
              "desc": "<p>Instructs the kernel to leave a multicast group at <code>multicastAddress</code> using the\n<code>IP_DROP_MEMBERSHIP</code> socket option. This method is automatically called by the\nkernel when the socket is closed or the process terminates, so most apps will\nnever have reason to call this.</p>\n<p>If <code>multicastInterface</code> is not specified, the operating system will attempt to\ndrop membership on all valid interfaces.</p>"
            },
            {
              "textRaw": "`socket.dropSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])`",
              "type": "method",
              "name": "dropSourceSpecificMembership",
              "meta": {
                "added": [
                  "v13.1.0",
                  "v12.16.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`sourceAddress` {string}",
                      "name": "sourceAddress",
                      "type": "string"
                    },
                    {
                      "textRaw": "`groupAddress` {string}",
                      "name": "groupAddress",
                      "type": "string"
                    },
                    {
                      "textRaw": "`multicastInterface` {string}",
                      "name": "multicastInterface",
                      "type": "string"
                    }
                  ]
                }
              ],
              "desc": "<p>Instructs the kernel to leave a source-specific multicast channel at the given\n<code>sourceAddress</code> and <code>groupAddress</code> using the <code>IP_DROP_SOURCE_MEMBERSHIP</code>\nsocket option. This method is automatically called by the kernel when the\nsocket is closed or the process terminates, so most apps will never have\nreason to call this.</p>\n<p>If <code>multicastInterface</code> is not specified, the operating system will attempt to\ndrop membership on all valid interfaces.</p>"
            },
            {
              "textRaw": "`socket.getRecvBufferSize()`",
              "type": "method",
              "name": "getRecvBufferSize",
              "meta": {
                "added": [
                  "v8.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} the `SO_RCVBUF` socket receive buffer size in bytes.",
                    "name": "return",
                    "type": "number",
                    "desc": "the `SO_RCVBUF` socket receive buffer size in bytes."
                  },
                  "params": []
                }
              ],
              "desc": "<p>This method throws <a href=\"errors.html#err_socket_buffer_size\"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.getSendBufferSize()`",
              "type": "method",
              "name": "getSendBufferSize",
              "meta": {
                "added": [
                  "v8.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} the `SO_SNDBUF` socket send buffer size in bytes.",
                    "name": "return",
                    "type": "number",
                    "desc": "the `SO_SNDBUF` socket send buffer size in bytes."
                  },
                  "params": []
                }
              ],
              "desc": "<p>This method throws <a href=\"errors.html#err_socket_buffer_size\"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.getSendQueueSize()`",
              "type": "method",
              "name": "getSendQueueSize",
              "meta": {
                "added": [
                  "v18.8.0",
                  "v16.19.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} Number of bytes queued for sending.",
                    "name": "return",
                    "type": "number",
                    "desc": "Number of bytes queued for sending."
                  },
                  "params": []
                }
              ]
            },
            {
              "textRaw": "`socket.getSendQueueCount()`",
              "type": "method",
              "name": "getSendQueueCount",
              "meta": {
                "added": [
                  "v18.8.0",
                  "v16.19.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} Number of send requests currently in the queue awaiting to be processed.",
                    "name": "return",
                    "type": "number",
                    "desc": "Number of send requests currently in the queue awaiting to be processed."
                  },
                  "params": []
                }
              ]
            },
            {
              "textRaw": "`socket.ref()`",
              "type": "method",
              "name": "ref",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {dgram.Socket}",
                    "name": "return",
                    "type": "dgram.Socket"
                  },
                  "params": []
                }
              ],
              "desc": "<p>By default, binding a socket will cause it to block the Node.js process from\nexiting as long as the socket is open. The <code>socket.unref()</code> method can be used\nto exclude the socket from the reference counting that keeps the Node.js\nprocess active. The <code>socket.ref()</code> method adds the socket back to the reference\ncounting and restores the default behavior.</p>\n<p>Calling <code>socket.ref()</code> multiples times will have no additional effect.</p>\n<p>The <code>socket.ref()</code> method returns a reference to the socket so calls can be\nchained.</p>"
            },
            {
              "textRaw": "`socket.remoteAddress()`",
              "type": "method",
              "name": "remoteAddress",
              "meta": {
                "added": [
                  "v12.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns an object containing the <code>address</code>, <code>family</code>, and <code>port</code> of the remote\nendpoint. This method throws an <a href=\"errors.html#err_socket_dgram_not_connected\"><code>ERR_SOCKET_DGRAM_NOT_CONNECTED</code></a> exception\nif the socket is not connected.</p>"
            },
            {
              "textRaw": "`socket.send(msg[, offset, length][, port][, address][, callback])`",
              "type": "method",
              "name": "send",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": [
                  {
                    "version": "v17.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/39190",
                    "description": "The `address` parameter now only accepts a `string`, `null` or `undefined`."
                  },
                  {
                    "version": [
                      "v14.5.0",
                      "v12.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/22413",
                    "description": "The `msg` parameter can now be any `TypedArray` or `DataView`."
                  },
                  {
                    "version": "v12.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/26871",
                    "description": "Added support for sending data on connected sockets."
                  },
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/11985",
                    "description": "The `msg` parameter can be an `Uint8Array` now."
                  },
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10473",
                    "description": "The `address` parameter is always optional now."
                  },
                  {
                    "version": "v6.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5929",
                    "description": "On success, `callback` will now be called with an `error` argument of `null` rather than `0`."
                  },
                  {
                    "version": "v5.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/4374",
                    "description": "The `msg` parameter can be an array now. Also, the `offset` and `length` parameters are optional now."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msg` {Buffer|TypedArray|DataView|string|Array} Message to be sent.",
                      "name": "msg",
                      "type": "Buffer|TypedArray|DataView|string|Array",
                      "desc": "Message to be sent."
                    },
                    {
                      "textRaw": "`offset` {integer} Offset in the buffer where the message starts.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Offset in the buffer where the message starts."
                    },
                    {
                      "textRaw": "`length` {integer} Number of bytes in the message.",
                      "name": "length",
                      "type": "integer",
                      "desc": "Number of bytes in the message."
                    },
                    {
                      "textRaw": "`port` {integer} Destination port.",
                      "name": "port",
                      "type": "integer",
                      "desc": "Destination port."
                    },
                    {
                      "textRaw": "`address` {string} Destination host name or IP address.",
                      "name": "address",
                      "type": "string",
                      "desc": "Destination host name or IP address."
                    },
                    {
                      "textRaw": "`callback` {Function} Called when the message has been sent.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Called when the message has been sent."
                    }
                  ]
                }
              ],
              "desc": "<p>Broadcasts a datagram on the socket.\nFor connectionless sockets, the destination <code>port</code> and <code>address</code> must be\nspecified. Connected sockets, on the other hand, will use their associated\nremote endpoint, so the <code>port</code> and <code>address</code> arguments must not be set.</p>\n<p>The <code>msg</code> argument contains the message to be sent.\nDepending on its type, different behavior can apply. If <code>msg</code> is a <code>Buffer</code>,\nany <code>TypedArray</code> or a <code>DataView</code>,\nthe <code>offset</code> and <code>length</code> specify the offset within the <code>Buffer</code> where the\nmessage begins and the number of bytes in the message, respectively.\nIf <code>msg</code> is a <code>String</code>, then it is automatically converted to a <code>Buffer</code>\nwith <code>'utf8'</code> encoding. With messages that\ncontain multi-byte characters, <code>offset</code> and <code>length</code> will be calculated with\nrespect to <a href=\"buffer.html#static-method-bufferbytelengthstring-encoding\">byte length</a> and not the character position.\nIf <code>msg</code> is an array, <code>offset</code> and <code>length</code> must not be specified.</p>\n<p>The <code>address</code> argument is a string. If the value of <code>address</code> is a host name,\nDNS will be used to resolve the address of the host. If <code>address</code> is not\nprovided or otherwise nullish, <code>'127.0.0.1'</code> (for <code>udp4</code> sockets) or <code>'::1'</code>\n(for <code>udp6</code> sockets) will be used by default.</p>\n<p>If the socket has not been previously bound with a call to <code>bind</code>, the socket\nis assigned a random port number and is bound to the \"all interfaces\" address\n(<code>'0.0.0.0'</code> for <code>udp4</code> sockets, <code>'::0'</code> for <code>udp6</code> sockets.)</p>\n<p>An optional <code>callback</code> function may be specified to as a way of reporting\nDNS errors or for determining when it is safe to reuse the <code>buf</code> object.\nDNS lookups delay the time to send for at least one tick of the\nNode.js event loop.</p>\n<p>The only way to know for sure that the datagram has been sent is by using a\n<code>callback</code>. If an error occurs and a <code>callback</code> is given, the error will be\npassed as the first argument to the <code>callback</code>. If a <code>callback</code> is not given,\nthe error is emitted as an <code>'error'</code> event on the <code>socket</code> object.</p>\n<p>Offset and length are optional but both <em>must</em> be set if either are used.\nThey are supported only when the first argument is a <code>Buffer</code>, a <code>TypedArray</code>,\nor a <code>DataView</code>.</p>\n<p>This method throws <a href=\"errors.html#err_socket_bad_port\"><code>ERR_SOCKET_BAD_PORT</code></a> if called on an unbound socket.</p>\n<p>Example of sending a UDP packet to a port on <code>localhost</code>;</p>\n<pre><code class=\"language-mjs\">import dgram from 'node:dgram';\nimport { Buffer } from 'node:buffer';\n\nconst message = Buffer.from('Some bytes');\nconst client = dgram.createSocket('udp4');\nclient.send(message, 41234, 'localhost', (err) => {\n  client.close();\n});\n</code></pre>\n<pre><code class=\"language-cjs\">const dgram = require('node:dgram');\nconst { Buffer } = require('node:buffer');\n\nconst message = Buffer.from('Some bytes');\nconst client = dgram.createSocket('udp4');\nclient.send(message, 41234, 'localhost', (err) => {\n  client.close();\n});\n</code></pre>\n<p>Example of sending a UDP packet composed of multiple buffers to a port on\n<code>127.0.0.1</code>;</p>\n<pre><code class=\"language-mjs\">import dgram from 'node:dgram';\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('Some ');\nconst buf2 = Buffer.from('bytes');\nconst client = dgram.createSocket('udp4');\nclient.send([buf1, buf2], 41234, (err) => {\n  client.close();\n});\n</code></pre>\n<pre><code class=\"language-cjs\">const dgram = require('node:dgram');\nconst { Buffer } = require('node:buffer');\n\nconst buf1 = Buffer.from('Some ');\nconst buf2 = Buffer.from('bytes');\nconst client = dgram.createSocket('udp4');\nclient.send([buf1, buf2], 41234, (err) => {\n  client.close();\n});\n</code></pre>\n<p>Sending multiple buffers might be faster or slower depending on the\napplication and operating system. Run benchmarks to\ndetermine the optimal strategy on a case-by-case basis. Generally speaking,\nhowever, sending multiple buffers is faster.</p>\n<p>Example of sending a UDP packet using a socket connected to a port on\n<code>localhost</code>:</p>\n<pre><code class=\"language-mjs\">import dgram from 'node:dgram';\nimport { Buffer } from 'node:buffer';\n\nconst message = Buffer.from('Some bytes');\nconst client = dgram.createSocket('udp4');\nclient.connect(41234, 'localhost', (err) => {\n  client.send(message, (err) => {\n    client.close();\n  });\n});\n</code></pre>\n<pre><code class=\"language-cjs\">const dgram = require('node:dgram');\nconst { Buffer } = require('node:buffer');\n\nconst message = Buffer.from('Some bytes');\nconst client = dgram.createSocket('udp4');\nclient.connect(41234, 'localhost', (err) => {\n  client.send(message, (err) => {\n    client.close();\n  });\n});\n</code></pre>",
              "modules": [
                {
                  "textRaw": "Note about UDP datagram size",
                  "name": "note_about_udp_datagram_size",
                  "desc": "<p>The maximum size of an IPv4/v6 datagram depends on the <code>MTU</code>\n(Maximum Transmission Unit) and on the <code>Payload Length</code> field size.</p>\n<ul>\n<li>\n<p>The <code>Payload Length</code> field is 16 bits wide, which means that a normal\npayload cannot exceed 64K octets including the internet header and data\n(65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header);\nthis is generally true for loopback interfaces, but such long datagram\nmessages are impractical for most hosts and networks.</p>\n</li>\n<li>\n<p>The <code>MTU</code> is the largest size a given link layer technology can support for\ndatagram messages. For any link, IPv4 mandates a minimum <code>MTU</code> of 68\noctets, while the recommended <code>MTU</code> for IPv4 is 576 (typically recommended\nas the <code>MTU</code> for dial-up type applications), whether they arrive whole or in\nfragments.</p>\n<p>For IPv6, the minimum <code>MTU</code> is 1280 octets. However, the mandatory minimum\nfragment reassembly buffer size is 1500 octets. The value of 68 octets is\nvery small, since most current link layer technologies, like Ethernet, have a\nminimum <code>MTU</code> of 1500.</p>\n</li>\n</ul>\n<p>It is impossible to know in advance the MTU of each link through which\na packet might travel. Sending a datagram greater than the receiver <code>MTU</code> will\nnot work because the packet will get silently dropped without informing the\nsource that the data did not reach its intended recipient.</p>",
                  "type": "module",
                  "displayName": "Note about UDP datagram size"
                }
              ]
            },
            {
              "textRaw": "`socket.setBroadcast(flag)`",
              "type": "method",
              "name": "setBroadcast",
              "meta": {
                "added": [
                  "v0.6.9"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`flag` {boolean}",
                      "name": "flag",
                      "type": "boolean"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets or clears the <code>SO_BROADCAST</code> socket option. When set to <code>true</code>, UDP\npackets may be sent to a local interface's broadcast address.</p>\n<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.setMulticastInterface(multicastInterface)`",
              "type": "method",
              "name": "setMulticastInterface",
              "meta": {
                "added": [
                  "v8.6.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`multicastInterface` {string}",
                      "name": "multicastInterface",
                      "type": "string"
                    }
                  ]
                }
              ],
              "desc": "<p><em>All references to scope in this section are referring to\n<a href=\"https://en.wikipedia.org/wiki/IPv6_address#Scoped_literal_IPv6_addresses\">IPv6 Zone Indices</a>, which are defined by <a href=\"https://tools.ietf.org/html/rfc4007\">RFC 4007</a>. In string form, an IP\nwith a scope index is written as <code>'IP%scope'</code> where scope is an interface name\nor interface number.</em></p>\n<p>Sets the default outgoing multicast interface of the socket to a chosen\ninterface or back to system interface selection. The <code>multicastInterface</code> must\nbe a valid string representation of an IP from the socket's family.</p>\n<p>For IPv4 sockets, this should be the IP configured for the desired physical\ninterface. All packets sent to multicast on the socket will be sent on the\ninterface determined by the most recent successful use of this call.</p>\n<p>For IPv6 sockets, <code>multicastInterface</code> should include a scope to indicate the\ninterface as in the examples that follow. In IPv6, individual <code>send</code> calls can\nalso use explicit scope in addresses, so only packets sent to a multicast\naddress without specifying an explicit scope are affected by the most recent\nsuccessful use of this call.</p>\n<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>\n<h4>Example: IPv6 outgoing multicast interface</h4>\n<p>On most systems, where scope format uses the interface name:</p>\n<pre><code class=\"language-js\">const socket = dgram.createSocket('udp6');\n\nsocket.bind(1234, () => {\n  socket.setMulticastInterface('::%eth1');\n});\n</code></pre>\n<p>On Windows, where scope format uses an interface number:</p>\n<pre><code class=\"language-js\">const socket = dgram.createSocket('udp6');\n\nsocket.bind(1234, () => {\n  socket.setMulticastInterface('::%2');\n});\n</code></pre>\n<h4>Example: IPv4 outgoing multicast interface</h4>\n<p>All systems use an IP of the host on the desired physical interface:</p>\n<pre><code class=\"language-js\">const socket = dgram.createSocket('udp4');\n\nsocket.bind(1234, () => {\n  socket.setMulticastInterface('10.0.0.2');\n});\n</code></pre>",
              "modules": [
                {
                  "textRaw": "Call results",
                  "name": "call_results",
                  "desc": "<p>A call on a socket that is not ready to send or no longer open may throw a <em>Not\nrunning</em> <a href=\"errors.html#class-error\"><code>Error</code></a>.</p>\n<p>If <code>multicastInterface</code> can not be parsed into an IP then an <em>EINVAL</em>\n<a href=\"errors.html#class-systemerror\"><code>System Error</code></a> is thrown.</p>\n<p>On IPv4, if <code>multicastInterface</code> is a valid address but does not match any\ninterface, or if the address does not match the family then\na <a href=\"errors.html#class-systemerror\"><code>System Error</code></a> such as <code>EADDRNOTAVAIL</code> or <code>EPROTONOSUP</code> is thrown.</p>\n<p>On IPv6, most errors with specifying or omitting scope will result in the socket\ncontinuing to use (or returning to) the system's default interface selection.</p>\n<p>A socket's address family's ANY address (IPv4 <code>'0.0.0.0'</code> or IPv6 <code>'::'</code>) can be\nused to return control of the sockets default outgoing interface to the system\nfor future multicast packets.</p>",
                  "type": "module",
                  "displayName": "Call results"
                }
              ]
            },
            {
              "textRaw": "`socket.setMulticastLoopback(flag)`",
              "type": "method",
              "name": "setMulticastLoopback",
              "meta": {
                "added": [
                  "v0.3.8"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`flag` {boolean}",
                      "name": "flag",
                      "type": "boolean"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option. When set to <code>true</code>,\nmulticast packets will also be received on the local interface.</p>\n<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.setMulticastTTL(ttl)`",
              "type": "method",
              "name": "setMulticastTTL",
              "meta": {
                "added": [
                  "v0.3.8"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`ttl` {integer}",
                      "name": "ttl",
                      "type": "integer"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the <code>IP_MULTICAST_TTL</code> socket option. While TTL generally stands for\n\"Time to Live\", in this context it specifies the number of IP hops that a\npacket is allowed to travel through, specifically for multicast traffic. Each\nrouter or gateway that forwards a packet decrements the TTL. If the TTL is\ndecremented to 0 by a router, it will not be forwarded.</p>\n<p>The <code>ttl</code> argument may be between 0 and 255. The default on most systems is <code>1</code>.</p>\n<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.setRecvBufferSize(size)`",
              "type": "method",
              "name": "setRecvBufferSize",
              "meta": {
                "added": [
                  "v8.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer}",
                      "name": "size",
                      "type": "integer"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the <code>SO_RCVBUF</code> socket option. Sets the maximum socket receive buffer\nin bytes.</p>\n<p>This method throws <a href=\"errors.html#err_socket_buffer_size\"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.setSendBufferSize(size)`",
              "type": "method",
              "name": "setSendBufferSize",
              "meta": {
                "added": [
                  "v8.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer}",
                      "name": "size",
                      "type": "integer"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the <code>SO_SNDBUF</code> socket option. Sets the maximum socket send buffer\nin bytes.</p>\n<p>This method throws <a href=\"errors.html#err_socket_buffer_size\"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.setTTL(ttl)`",
              "type": "method",
              "name": "setTTL",
              "meta": {
                "added": [
                  "v0.1.101"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`ttl` {integer}",
                      "name": "ttl",
                      "type": "integer"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the <code>IP_TTL</code> socket option. While TTL generally stands for \"Time to Live\",\nin this context it specifies the number of IP hops that a packet is allowed to\ntravel through. Each router or gateway that forwards a packet decrements the\nTTL. If the TTL is decremented to 0 by a router, it will not be forwarded.\nChanging TTL values is typically done for network probes or when multicasting.</p>\n<p>The <code>ttl</code> argument may be between 1 and 255. The default on most systems\nis 64.</p>\n<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>"
            },
            {
              "textRaw": "`socket.unref()`",
              "type": "method",
              "name": "unref",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {dgram.Socket}",
                    "name": "return",
                    "type": "dgram.Socket"
                  },
                  "params": []
                }
              ],
              "desc": "<p>By default, binding a socket will cause it to block the Node.js process from\nexiting as long as the socket is open. The <code>socket.unref()</code> method can be used\nto exclude the socket from the reference counting that keeps the Node.js\nprocess active, allowing the process to exit even if the socket is still\nlistening.</p>\n<p>Calling <code>socket.unref()</code> multiple times will have no addition effect.</p>\n<p>The <code>socket.unref()</code> method returns a reference to the socket so calls can be\nchained.</p>"
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "`node:dgram` module functions",
          "name": "`node:dgram`_module_functions",
          "methods": [
            {
              "textRaw": "`dgram.createSocket(options[, callback])`",
              "type": "method",
              "name": "createSocket",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v15.8.0",
                    "pr-url": "https://github.com/nodejs/node/pull/37026",
                    "description": "AbortSignal support was added."
                  },
                  {
                    "version": "v11.4.0",
                    "pr-url": "https://github.com/nodejs/node/pull/23798",
                    "description": "The `ipv6Only` option is supported."
                  },
                  {
                    "version": "v8.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/13623",
                    "description": "The `recvBufferSize` and `sendBufferSize` options are supported now."
                  },
                  {
                    "version": "v8.6.0",
                    "pr-url": "https://github.com/nodejs/node/pull/14560",
                    "description": "The `lookup` option is supported."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {dgram.Socket}",
                    "name": "return",
                    "type": "dgram.Socket"
                  },
                  "params": [
                    {
                      "textRaw": "`options` {Object} Available options are:",
                      "name": "options",
                      "type": "Object",
                      "desc": "Available options are:",
                      "options": [
                        {
                          "textRaw": "`type` {string} The family of socket. Must be either `'udp4'` or `'udp6'`. Required.",
                          "name": "type",
                          "type": "string",
                          "desc": "The family of socket. Must be either `'udp4'` or `'udp6'`. Required."
                        },
                        {
                          "textRaw": "`reuseAddr` {boolean} When `true` [`socket.bind()`][] will reuse the address, even if another process has already bound a socket on it. **Default:** `false`.",
                          "name": "reuseAddr",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "When `true` [`socket.bind()`][] will reuse the address, even if another process has already bound a socket on it."
                        },
                        {
                          "textRaw": "`ipv6Only` {boolean} Setting `ipv6Only` to `true` will disable dual-stack support, i.e., binding to address `::` won't make `0.0.0.0` be bound. **Default:** `false`.",
                          "name": "ipv6Only",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "Setting `ipv6Only` to `true` will disable dual-stack support, i.e., binding to address `::` won't make `0.0.0.0` be bound."
                        },
                        {
                          "textRaw": "`recvBufferSize` {number} Sets the `SO_RCVBUF` socket value.",
                          "name": "recvBufferSize",
                          "type": "number",
                          "desc": "Sets the `SO_RCVBUF` socket value."
                        },
                        {
                          "textRaw": "`sendBufferSize` {number} Sets the `SO_SNDBUF` socket value.",
                          "name": "sendBufferSize",
                          "type": "number",
                          "desc": "Sets the `SO_SNDBUF` socket value."
                        },
                        {
                          "textRaw": "`lookup` {Function} Custom lookup function. **Default:** [`dns.lookup()`][].",
                          "name": "lookup",
                          "type": "Function",
                          "default": "[`dns.lookup()`][]",
                          "desc": "Custom lookup function."
                        },
                        {
                          "textRaw": "`signal` {AbortSignal} An AbortSignal that may be used to close a socket.",
                          "name": "signal",
                          "type": "AbortSignal",
                          "desc": "An AbortSignal that may be used to close a socket."
                        }
                      ]
                    },
                    {
                      "textRaw": "`callback` {Function} Attached as a listener for `'message'` events. Optional.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Attached as a listener for `'message'` events. Optional."
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a <code>dgram.Socket</code> object. Once the socket is created, calling\n<a href=\"#socketbindport-address-callback\"><code>socket.bind()</code></a> will instruct the socket to begin listening for datagram\nmessages. When <code>address</code> and <code>port</code> are not passed to <a href=\"#socketbindport-address-callback\"><code>socket.bind()</code></a> the\nmethod will bind the socket to the \"all interfaces\" address on a random port\n(it does the right thing for both <code>udp4</code> and <code>udp6</code> sockets). The bound address\nand port can be retrieved using <a href=\"#socketaddress\"><code>socket.address().address</code></a> and\n<a href=\"#socketaddress\"><code>socket.address().port</code></a>.</p>\n<p>If the <code>signal</code> option is enabled, calling <code>.abort()</code> on the corresponding\n<code>AbortController</code> is similar to calling <code>.close()</code> on the socket:</p>\n<pre><code class=\"language-js\">const controller = new AbortController();\nconst { signal } = controller;\nconst server = dgram.createSocket({ type: 'udp4', signal });\nserver.on('message', (msg, rinfo) => {\n  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n// Later, when you want to close the server.\ncontroller.abort();\n</code></pre>"
            },
            {
              "textRaw": "`dgram.createSocket(type[, callback])`",
              "type": "method",
              "name": "createSocket",
              "meta": {
                "added": [
                  "v0.1.99"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {dgram.Socket}",
                    "name": "return",
                    "type": "dgram.Socket"
                  },
                  "params": [
                    {
                      "textRaw": "`type` {string} Either `'udp4'` or `'udp6'`.",
                      "name": "type",
                      "type": "string",
                      "desc": "Either `'udp4'` or `'udp6'`."
                    },
                    {
                      "textRaw": "`callback` {Function} Attached as a listener to `'message'` events.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Attached as a listener to `'message'` events."
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a <code>dgram.Socket</code> object of the specified <code>type</code>.</p>\n<p>Once the socket is created, calling <a href=\"#socketbindport-address-callback\"><code>socket.bind()</code></a> will instruct the\nsocket to begin listening for datagram messages. When <code>address</code> and <code>port</code> are\nnot passed to <a href=\"#socketbindport-address-callback\"><code>socket.bind()</code></a> the method will bind the socket to the \"all\ninterfaces\" address on a random port (it does the right thing for both <code>udp4</code>\nand <code>udp6</code> sockets). The bound address and port can be retrieved using\n<a href=\"#socketaddress\"><code>socket.address().address</code></a> and <a href=\"#socketaddress\"><code>socket.address().port</code></a>.</p>"
            }
          ],
          "type": "module",
          "displayName": "`node:dgram` module functions"
        }
      ],
      "type": "module",
      "displayName": "dgram"
    }
  ]
}